<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint Pro - Editor Completo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2b2b2b;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            color: #fff;
        }

        .menu-bar {
            background: #1e1e1e;
            border-bottom: 1px solid #3e3e3e;
            padding: 5px 10px;
            display: flex;
            gap: 20px;
            font-size: 13px;
        }

        .menu-item {
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #3e3e3e;
        }

        .toolbar {
            background: #252525;
            border-bottom: 1px solid #3e3e3e;
            padding: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            max-height: 200px;
            overflow-y: auto;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 5px 10px;
            background: #1e1e1e;
            border-radius: 5px;
            border: 1px solid #3e3e3e;
        }

        .tool-btn {
            background: #3e3e3e;
            border: 2px solid #555;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            color: #fff;
            min-width: 40px;
            justify-content: center;
        }

        .tool-btn:hover {
            background: #4e4e4e;
            border-color: #777;
            transform: translateY(-1px);
        }

        .tool-btn.active {
            background: #0d7377;
            color: white;
            border-color: #14FFEC;
            box-shadow: 0 0 10px rgba(20, 255, 236, 0.3);
        }

        .color-picker {
            width: 50px;
            height: 35px;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
        }

        .size-input, .opacity-input {
            width: 70px;
            padding: 6px;
            border: 2px solid #555;
            border-radius: 4px;
            font-size: 13px;
            background: #3e3e3e;
            color: #fff;
        }

        label {
            font-size: 12px;
            color: #aaa;
            font-weight: 500;
        }

        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .sidebar-left {
            width: 80px;
            background: #1e1e1e;
            border-right: 1px solid #3e3e3e;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow-y: auto;
        }

        .sidebar-right {
            width: 250px;
            background: #1e1e1e;
            border-left: 1px solid #3e3e3e;
            padding: 15px;
            overflow-y: auto;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: auto;
            background: #2b2b2b;
            position: relative;
        }

        #canvas {
            background: white;
            cursor: crosshair;
            box-shadow: 0 8px 30px rgba(0,0,0,0.7);
            border-radius: 2px;
            image-rendering: pixelated;
        }

        .status-bar {
            background: #1e1e1e;
            border-top: 1px solid #3e3e3e;
            padding: 8px 15px;
            font-size: 11px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        select {
            padding: 6px 10px;
            border: 2px solid #555;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            background: #3e3e3e;
            color: #fff;
        }

        input[type="text"], input[type="number"] {
            padding: 6px 10px;
            border: 2px solid #555;
            border-radius: 4px;
            font-size: 13px;
            background: #3e3e3e;
            color: #fff;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .color-swatch {
            width: 28px;
            height: 28px;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: #14FFEC;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2b2b2b;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.5);
            border: 1px solid #3e3e3e;
            max-width: 500px;
            min-width: 400px;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #14FFEC;
            font-size: 20px;
        }

        .modal-content input, .modal-content select {
            margin: 10px 0;
            width: 100%;
        }

        .modal-content button {
            margin: 10px 5px 0 0;
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #0d7377;
            color: white;
        }

        .btn-primary:hover {
            background: #0a5d60;
        }

        .btn-secondary {
            background: #555;
            color: white;
        }

        .btn-secondary:hover {
            background: #666;
        }

        .panel {
            background: #252525;
            border: 1px solid #3e3e3e;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: bold;
            color: #14FFEC;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #3e3e3e;
        }

        .layer {
            background: #3e3e3e;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 2px solid transparent;
        }

        .layer.active {
            border-color: #14FFEC;
            background: #4e4e4e;
        }

        .layer:hover {
            background: #4e4e4e;
        }

        .layer[draggable="true"] {
            cursor: grab;
        }

        .layer[draggable="true"]:active {
            cursor: grabbing;
        }

        .slider {
            width: 100%;
            margin: 10px 0;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #3e3e3e;
            outline: none;
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #14FFEC;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #14FFEC;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .zoom-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .grid-overlay {
            position: absolute;
            pointer-events: none;
            top: 0;
            left: 0;
            z-index: 10;
            display: none;
        }

        .tool-icon {
            font-size: 20px;
        }

        .brush-preview {
            width: 60px;
            height: 60px;
            background: #3e3e3e;
            border: 2px solid #555;
            border-radius: 4px;
            margin: 10px auto;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .brush-cursor {
            background: #000;
            border-radius: 50%;
            position: absolute;
        }

        .gradient-preview {
            width: 100%;
            height: 40px;
            border: 2px solid #555;
            border-radius: 4px;
            margin: 10px 0;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .filter-btn {
            padding: 10px;
            background: #3e3e3e;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            color: #fff;
        }

        .filter-btn:hover {
            background: #4e4e4e;
            border-color: #14FFEC;
        }

        .symmetry-line {
            position: absolute;
            background: rgba(20, 255, 236, 0.3);
            pointer-events: none;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: #2b2b2b;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.8);
            z-index: 1;
            border: 1px solid #3e3e3e;
            border-radius: 4px;
            margin-top: 5px;
        }

        .dropdown-content a {
            color: #fff;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            font-size: 13px;
        }

        .dropdown-content a:hover {
            background: #3e3e3e;
        }

        .dropdown-divider {
            height: 1px;
            background: #555;
            margin: 5px 0;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .minimap {
            width: 100%;
            height: 150px;
            background: #3e3e3e;
            border: 2px solid #555;
            border-radius: 4px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        .color-mixer {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .mixed-color {
            width: 100%;
            height: 50px;
            border: 2px solid #555;
            border-radius: 4px;
            margin-top: 10px;
        }

        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .shortcuts-help {
            font-size: 11px;
            color: #888;
            margin-top: 10px;
            padding: 10px;
            background: #1e1e1e;
            border-radius: 4px;
        }

        .transform-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .spinner {
            border: 3px solid #3e3e3e;
            border-top: 3px solid #14FFEC;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #0d7377;
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            display: none;
            z-index: 1001;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Estilos para reglas y cuadr√≠cula */
        .canvas-container {
            position: relative;
            display: inline-block;
        }

        .ruler {
            position: absolute;
            background: #2b2b2b;
            color: #fff;
            font-size: 10px;
            font-family: monospace;
            z-index: 5;
            border: 1px solid #555;
        }

        .ruler-horizontal {
            left: 25px;
            top: 0;
            height: 25px;
            width: 100%;
            background: linear-gradient(to bottom, #2b2b2b 0%, #1e1e1e 100%);
            border-bottom: 1px solid #14FFEC;
            overflow: hidden;
        }

        .ruler-vertical {
            left: 0;
            top: 25px;
            width: 25px;
            height: 100%;
            background: linear-gradient(to right, #2b2b2b 0%, #1e1e1e 100%);
            border-right: 1px solid #14FFEC;
            overflow: hidden;
        }

        .ruler-corner {
            position: absolute;
            left: 0;
            top: 0;
            width: 25px;
            height: 25px;
            background: #1e1e1e;
            border: 1px solid #555;
            border-bottom-color: #14FFEC;
            border-right-color: #14FFEC;
        }

        .grid-overlay {
            position: absolute;
            top: 25px;
            left: 25px;
            pointer-events: none;
            z-index: 1;
            background-image: 
                linear-gradient(to right, rgba(20, 255, 236, 0.4) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(20, 255, 236, 0.4) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .ruler-tick {
            position: absolute;
            background: #555;
            color: #14FFEC;
            font-size: 8px;
            text-align: center;
        }

        .ruler-horizontal .ruler-tick {
            border-left: 1px solid #14FFEC;
            height: 8px;
            width: 1px;
            top: 17px;
        }

        .ruler-vertical .ruler-tick {
            border-top: 1px solid #14FFEC;
            width: 8px;
            height: 1px;
            left: 17px;
        }

        .ruler-tick-major {
            background: transparent;
            color: #14FFEC;
            font-weight: bold;
            font-size: 9px;
            line-height: 1;
        }

        .ruler-horizontal .ruler-tick-major {
            height: 25px;
            top: 0;
            padding-left: 2px;
            padding-top: 2px;
            min-width: 20px;
            border-left: 2px solid #14FFEC;
        }

        .ruler-vertical .ruler-tick-major {
            width: 25px;
            left: 0;
            padding-top: 2px;
            padding-left: 2px;
            min-height: 15px;
            border-top: 2px solid #14FFEC;
            writing-mode: horizontal-tb;
            transform: rotate(-90deg);
            transform-origin: left top;
        }

        .ruler-tick-minor {
            background: #666;
        }

        .ruler-number {
            position: absolute;
            color: #14FFEC;
            font-size: 9px;
            text-align: center;
        }

        .canvas-with-rulers {
            position: relative;
            margin-left: 25px;
            margin-top: 25px;
        }
    </style>
</head>
<body>
    <!-- Menu Bar -->
    <div class="menu-bar">
        <div class="dropdown">
            <div class="menu-item">Archivo</div>
            <div class="dropdown-content">
                <a onclick="newCanvas()">Nuevo (Ctrl+N)</a>
                <div class="dropdown-divider"></div>
                <a onclick="saveProject()">üíæ Guardar Proyecto (editable)</a>
                <a onclick="saveAsProject()">üíæ Guardar Proyecto Como...</a>
                <a onclick="loadProject()">üìÇ Cargar Proyecto</a>
                <div class="dropdown-divider"></div>
                <a onclick="loadImage()">üì• Importar Imagen (Ctrl+O)</a>
                <a onclick="saveImage()">üñºÔ∏è Exportar PNG Completo (Ctrl+S)</a>
                <a onclick="saveAsJPEG()">üñºÔ∏è Exportar JPEG Completo</a>
                <a onclick="exportCurrentLayerOnly()">üìÑ Exportar Solo Capa Actual</a>
                <div class="dropdown-divider"></div>
                <a onclick="toggleAutoSave()">üîÑ Alternar Autoguardado</a>
            </div>
        </div>
        <div class="dropdown">
            <div class="menu-item">Editar</div>
            <div class="dropdown-content">
                <a onclick="undo()">Deshacer (Ctrl+Z)</a>
                <a onclick="redo()">Rehacer (Ctrl+Y)</a>
                <div class="dropdown-divider"></div>
                <a onclick="copyCanvasToClipboard()">Copiar Canvas (Ctrl+C)</a>
                <a onclick="pasteFromClipboard()">Pegar Imagen (Ctrl+V)</a>
                <div class="dropdown-divider"></div>
                <a onclick="selectAll()">üßÆ Seleccionar Todo (Ctrl+A)</a>
                <a onclick="invertSelection()">üîÑ Invertir Selecci√≥n</a>
                <a onclick="deleteSelection()">üóëÔ∏è Eliminar Selecci√≥n (Supr)</a>
                <a onclick="clearSelection()">‚ùå Cancelar Selecci√≥n (Esc)</a>
                <div class="dropdown-divider"></div>
                <a onclick="toggleTransparentSelection()">
                    <span id="transparentSelectionIndicator">‚òê</span> Selecci√≥n Transparente
                </a>
                <div class="dropdown-divider"></div>
                <a onclick="clearCanvas()">Limpiar todo</a>
                <div class="dropdown-divider"></div>
                <a onclick="setFillTolerance()">Tolerancia de relleno...</a>
            </div>
        </div>
        <div class="dropdown">
            <div class="menu-item">Imagen</div>
            <div class="dropdown-content">
                <a onclick="resizeCanvas()">Cambiar tama√±o</a>
                <a onclick="rotateCanvas(90)">Rotar 90¬∞ derecha</a>
                <a onclick="rotateCanvas(-90)">Rotar 90¬∞ izquierda</a>
                <a onclick="flipHorizontal()">Voltear horizontal</a>
                <a onclick="flipVertical()">Voltear vertical</a>
                <a onclick="cropCanvas()">Recortar</a>
                <div class="dropdown-divider"></div>
                <a onclick="setBackgroundColor()">üé® Color de Fondo...</a>
                <a onclick="setBackgroundTransparent()">‚¨ú Fondo Transparente</a>
            </div>
        </div>
        <div class="dropdown">
            <div class="menu-item">Filtros</div>
            <div class="dropdown-content">
                <a onclick="applyFilter('grayscale')">Escala de grises</a>
                <a onclick="applyFilter('sepia')">Sepia</a>
                <a onclick="applyFilter('invert')">Invertir colores</a>
                <a onclick="applyFilter('blur')">Desenfoque</a>
                <a onclick="applyFilter('sharpen')">Nitidez</a>
                <a onclick="applyFilter('brightness')">Brillo</a>
                <a onclick="applyFilter('contrast')">Contraste</a>
                <a onclick="applyFilter('pixelate')">Pixelar</a>
            </div>
        </div>
        <div class="dropdown">
            <div class="menu-item">üé® Capas</div>
            <div class="dropdown-content">
                <a onclick="addLayer()">‚ûï Nueva Capa</a>
                <a onclick="duplicateLayer()">üìã Duplicar Capa Actual</a>
                <a onclick="deleteLayer()">üóëÔ∏è Eliminar Capa Actual</a>
                <a onclick="mergeLayerDown()">‚¨áÔ∏è Combinar con Inferior</a>
                <a onclick="flattenLayers()">üñºÔ∏è Aplanar Todas las Capas</a>
            </div>
        </div>
        <div class="dropdown">
            <div class="menu-item">Ver</div>
            <div class="dropdown-content">
                <a onclick="toggleGrid()">Mostrar cuadr√≠cula</a>
                <a onclick="setGridSize()">Configurar cuadr√≠cula...</a>
                <a onclick="toggleRulers()">Mostrar reglas</a>
                <a onclick="setRulerUnit()">Configurar reglas...</a>
                <a onclick="toggleMinimap()">Minimapa</a>
                <a onclick="showResizeDialog()">Redimensionar canvas...</a>
                <a onclick="fullscreen()">Pantalla completa</a>
            </div>
        </div>
        <div class="dropdown">
            <div class="menu-item">Ayuda</div>
            <div class="dropdown-content">
                <a onclick="showShortcuts()">Atajos de teclado</a>
                <a onclick="showAbout()">Acerca de</a>
            </div>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <div class="tool-group">
            <button class="tool-btn" onclick="newCanvas()" title="Nuevo">üìÑ</button>
            <button class="tool-btn" onclick="saveProject()" title="Guardar Proyecto">üíæüìÅ</button>
            <button class="tool-btn" onclick="loadProject()" title="Cargar Proyecto">üìÅüìÑ</button>
            <button class="tool-btn" onclick="saveImage()" title="Exportar Imagen">ÔøΩÔ∏è</button>
        </div>

        <div class="tool-group">
            <button class="tool-btn" onclick="undo()" title="Deshacer (Ctrl+Z)">‚Ü∂</button>
            <button class="tool-btn" onclick="redo()" title="Rehacer (Ctrl+Y)">‚Ü∑</button>
        </div>
        
        <div class="tool-group">
            <button class="tool-btn" onclick="copyCanvasToClipboard()" title="Copiar Canvas (Ctrl+C)">üìã</button>
            <button class="tool-btn" onclick="pasteFromClipboard()" title="Pegar desde Portapapeles (Ctrl+V)">üìÑüìã</button>
        </div>

        <div class="tool-group">
            <label>Color 1:</label>
            <input type="color" id="colorPicker" class="color-picker" value="#000000" onchange="updateColor()">
            <label>Color 2:</label>
            <input type="color" id="colorPicker2" class="color-picker" value="#ffffff" onchange="updateColor2()">
            <button class="tool-btn" onclick="swapColors()" title="Intercambiar colores">‚áÑ</button>
        </div>

        <div class="tool-group">
            <label>Tama√±o:</label>
            <input type="number" id="brushSize" class="size-input" value="5" min="1" max="500" onchange="updateBrushSize()">
            <input type="range" id="brushSizeSlider" min="1" max="500" value="5" onchange="updateBrushSizeFromSlider()" style="width: 100px;">
        </div>

        <div class="tool-group">
            <label>Opacidad:</label>
            <input type="range" id="opacitySlider" min="0" max="100" value="100" onchange="updateOpacity()" style="width: 100px;">
            <span id="opacityValue">100%</span>
        </div>

        <div class="tool-group">
            <label>Zoom:</label>
            <button class="tool-btn" onclick="zoomIn()" title="Acercar">+</button>
            <span id="zoomLevel">100%</span>
            <button class="tool-btn" onclick="zoomOut()" title="Alejar">-</button>
            <button class="tool-btn" onclick="resetZoom()" title="Restablecer">‚äô</button>
        </div>

        <div class="tool-group">
            <label>Vista:</label>
            <button class="tool-btn" onclick="toggleRulers()" id="rulersBtn" title="Mostrar/Ocultar Reglas">üìè</button>
            <button class="tool-btn" onclick="toggleGrid()" id="gridBtn" title="Mostrar/Ocultar Cuadr√≠cula">‚äû</button>
            <button class="tool-btn" onclick="showResizeDialog()" title="Redimensionar Canvas">üìê</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Sidebar - Tools -->
        <div class="sidebar-left">
            <button class="tool-btn active" onclick="selectTool('brush')" id="brush-btn" title="Pincel (B)">
                <span class="tool-icon">üñåÔ∏è</span>
            </button>
            <button class="tool-btn" onclick="selectTool('pencil')" id="pencil-btn" title="L√°piz (P)">
                <span class="tool-icon">‚úèÔ∏è</span>
            </button>
            <button class="tool-btn" onclick="selectTool('spray')" id="spray-btn" title="Aerosol (A)">
                <span class="tool-icon">üí®</span>
            </button>
            <button class="tool-btn" onclick="selectTool('eraser')" id="eraser-btn" title="Borrador (E)">
                <span class="tool-icon">üßπ</span>
            </button>
            <button class="tool-btn" onclick="selectTool('fill')" id="fill-btn" title="Relleno (F)">
                <span class="tool-icon">ü™£</span>
            </button>
            <button class="tool-btn" onclick="selectTool('eyedropper')" id="eyedropper-btn" title="Cuentagotas (I)">
                <span class="tool-icon">üíß</span>
            </button>
            <button class="tool-btn" onclick="selectTool('line')" id="line-btn" title="L√≠nea (L)">
                <span class="tool-icon">üìè</span>
            </button>
            <button class="tool-btn" onclick="selectTool('rectangle')" id="rectangle-btn" title="Rect√°ngulo (R)">
                <span class="tool-icon">‚¨ú</span>
            </button>
            <button class="tool-btn" onclick="selectTool('circle')" id="circle-btn" title="C√≠rculo (C)">
                <span class="tool-icon">‚≠ï</span>
            </button>
            <button class="tool-btn" onclick="selectTool('triangle')" id="triangle-btn" title="Tri√°ngulo (T)">
                <span class="tool-icon">üî∫</span>
            </button>
            <button class="tool-btn" onclick="selectTool('polygon')" id="polygon-btn" title="Pol√≠gono (G)">
                <span class="tool-icon">‚¨°</span>
            </button>
            <button class="tool-btn" onclick="selectTool('star')" id="star-btn" title="Estrella (S)">
                <span class="tool-icon">‚≠ê</span>
            </button>
            <button class="tool-btn" onclick="selectTool('arrow')" id="arrow-btn" title="Flecha">
                <span class="tool-icon">‚û°Ô∏è</span>
            </button>
            <button class="tool-btn" onclick="selectTool('curve')" id="curve-btn" title="Curva">
                <span class="tool-icon">„Ä∞Ô∏è</span>
            </button>
            <button class="tool-btn" onclick="selectTool('text')" id="text-btn" title="Texto (X)">
                <span class="tool-icon">üìù</span>
            </button>
            <button class="tool-btn" onclick="selectTool('gradient')" id="gradient-btn" title="Gradiente">
                <span class="tool-icon">üåà</span>
            </button>
            <button class="tool-btn" onclick="selectTool('select')" id="select-btn" title="Seleccionar Rectangular (M)">
                <span class="tool-icon">‚óªÔ∏è</span>
            </button>
            <button class="tool-btn" onclick="selectTool('freeformSelect')" id="freeform-select-btn" title="Selecci√≥n Libre (Shift+M)">
                <span class="tool-icon">‚úèÔ∏è‚óªÔ∏è</span>
            </button>
            <button class="tool-btn" onclick="selectTool('move')" id="move-btn" title="Mover (V)">
                <span class="tool-icon">‚úã</span>
            </button>
            <button class="tool-btn" onclick="selectTool('clone')" id="clone-btn" title="Clonar">
                <span class="tool-icon">üìã</span>
            </button>
            <button class="tool-btn" onclick="selectTool('blur')" id="blur-btn" title="Desenfocar">
                <span class="tool-icon">üå´Ô∏è</span>
            </button>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area" id="canvasArea">
            <div class="spinner" id="spinner"></div>
            <div class="canvas-container" id="canvasContainer">
                <div class="ruler-corner" id="rulerCorner"></div>
                <div class="ruler ruler-horizontal" id="rulerHorizontal"></div>
                <div class="ruler ruler-vertical" id="rulerVertical"></div>
                <div class="grid-overlay" id="gridOverlay"></div>
                <canvas id="canvas" width="1200" height="800"></canvas>
            </div>
        </div>

        <!-- Right Sidebar - Properties -->
        <div class="sidebar-right">
            <!-- Brush Settings -->
            <div class="panel">
                <div class="panel-title">‚öôÔ∏è Configuraci√≥n de Pincel</div>
                <label>Tipo de pincel:</label>
                <select id="brushType" onchange="updateBrushType()">
                    <option value="round">Redondo</option>
                    <option value="square">Cuadrado</option>
                    <option value="soft">Suave</option>
                    <option value="calligraphy">Caligraf√≠a</option>
                    <option value="spray">Aerosol</option>
                    <option value="pattern">Patr√≥n</option>
                </select>
                
                <div class="brush-preview" id="brushPreview">
                    <div class="brush-cursor" id="brushCursor"></div>
                </div>
                
                <label>Suavizado:</label>
                <input type="range" id="smoothingSlider" min="0" max="100" value="0" onchange="updateSmoothing()">
                
                <label>Espaciado:</label>
                <input type="range" id="spacingSlider" min="1" max="50" value="1" onchange="updateSpacing()">
                
                <label>Simetr√≠a:</label>
                <select id="symmetryMode" onchange="updateSymmetry()">
                    <option value="none">Ninguna</option>
                    <option value="horizontal">Horizontal</option>
                    <option value="vertical">Vertical</option>
                    <option value="both">Ambas</option>
                    <option value="radial">Radial</option>
                </select>
            </div>

            <!-- Color Palette -->
            <div class="panel">
                <div class="panel-title">üé® Paleta de Colores</div>
                <div class="color-palette" id="colorPalette"></div>
                <button class="tool-btn" style="width: 100%; margin-top: 10px;" onclick="addCustomColor()">+ Agregar color personalizado</button>
            </div>

            <!-- Gradient Settings -->
            <div class="panel">
                <div class="panel-title">üåà Configuraci√≥n de Gradiente</div>
                <label>Tipo de gradiente:</label>
                <select id="gradientType" onchange="updateGradientType()">
                    <option value="linear">Lineal</option>
                    <option value="radial">Radial</option>
                    <option value="conic">C√≥nico</option>
                </select>
                <div class="gradient-preview" id="gradientPreview"></div>
            </div>

            <!-- Layers Panel -->
            <div class="panel">
                <div class="panel-title">üìö Capas</div>
                <div id="layersList">
                    <div class="layer active" onclick="selectLayer(0)">
                        <span>Capa 1</span>
                        <span>üëÅÔ∏è</span>
                    </div>
                </div>
                <button class="tool-btn" style="width: 100%; margin-top: 10px;" onclick="addLayer()">+ Nueva capa</button>
            </div>

            <!-- Filters -->
            <div class="panel">
                <div class="panel-title">‚ú® Filtros R√°pidos</div>
                <div class="filter-grid">
                    <button class="filter-btn" onclick="applyFilter('grayscale')">Escala de grises</button>
                    <button class="filter-btn" onclick="applyFilter('sepia')">Sepia</button>
                    <button class="filter-btn" onclick="applyFilter('invert')">Invertir</button>
                    <button class="filter-btn" onclick="applyFilter('blur')">Desenfoque</button>
                    <button class="filter-btn" onclick="applyFilter('sharpen')">Nitidez</button>
                    <button class="filter-btn" onclick="applyFilter('emboss')">Relieve</button>
                    <button class="filter-btn" onclick="applyFilter('edge')">Detectar bordes</button>
                    <button class="filter-btn" onclick="applyFilter('vintage')">Vintage</button>
                </div>
            </div>

            <!-- Minimap -->
            <div class="panel">
                <div class="panel-title">üó∫Ô∏è Minimapa</div>
                <div class="minimap">
                    <canvas id="minimapCanvas" class="minimap-canvas"></canvas>
                </div>
            </div>

            <!-- Shape Manipulation Info -->
            <div class="panel">
                <div class="panel-title">üîß Manipulaci√≥n de Figuras</div>
                <div class="shortcuts-help">
                    <strong>üñ±Ô∏è Controles:</strong><br>
                    ‚Ä¢ <strong>Ctrl + Click:</strong> Mover figuras<br>
                    ‚Ä¢ <strong>Shift + Click:</strong> Rotar figuras<br>
                    ‚Ä¢ <strong>Click derecho + Rueda:</strong> Escalar<br><br>
                    
                    <strong>üí° Consejos:</strong><br>
                    ‚Ä¢ Las figuras seleccionadas se resaltan en rojo<br>
                    ‚Ä¢ Si hay figuras superpuestas, haz clic varias veces para cambiar entre ellas<br>
                    ‚Ä¢ Mant√©n presionada la tecla mientras arrastras
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <span id="status">Listo | Herramienta: Pincel</span>
        <div class="zoom-controls">
            <span id="canvasSize">1200 x 800 px</span>
            <span style="margin: 0 10px;">|</span>
            <span id="coordinates">X: 0, Y: 0</span>
            <span style="margin: 0 10px;">|</span>
            <span id="rotationInfo" style="display: none;">Rotaci√≥n: <span id="rotationAngle">0¬∞</span></span>
            <span id="rotationSeparator" style="margin: 0 10px; display: none;">|</span>
            <span id="fileSize">Tama√±o: 0 KB</span>
        </div>
    </div>

    <!-- Modals -->
    <div id="textModal" class="modal">
        <div class="modal-content">
            <h3>‚úçÔ∏è Agregar Texto</h3>
            <input type="text" id="textInput" placeholder="Escribe tu texto...">
            <label>Fuente:</label>
            <select id="fontFamily">
                <option value="Arial">Arial</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Georgia">Georgia</option>
                <option value="Verdana">Verdana</option>
                <option value="Comic Sans MS">Comic Sans MS</option>
                <option value="Impact">Impact</option>
            </select>
            <label>Tama√±o: <input type="number" id="fontSize" value="30" min="8" max="500"></label>
            <label>Alineaci√≥n:
                <select id="textAlign">
                    <option value="left">Izquierda</option>
                    <option value="center">Centro</option>
                    <option value="right">Derecha</option>
                </select>
            </label>
            <label>
                <input type="checkbox" id="boldText"> Negrita
                <input type="checkbox" id="italicText"> Cursiva
            </label>
            <button class="btn-primary" onclick="addText()">Agregar</button>
            <button class="btn-secondary" onclick="closeTextModal()">Cancelar</button>
        </div>
    </div>

    <div id="resizeModal" class="modal">
        <div class="modal-content">
            <h3>üìê Cambiar Tama√±o del Canvas</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <div style="flex: 1;">
                    <label>Ancho: <input type="number" id="newWidth" value="1200" min="1" max="5000"></label>
                    <label>Alto: <input type="number" id="newHeight" value="800" min="1" max="5000"></label>
                    <label><input type="checkbox" id="maintainAspect" checked> Mantener proporci√≥n</label>
                </div>
                <div style="flex: 1;">
                    <label>Presets comunes:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 5px;">
                        <button class="btn-secondary" onclick="resizeCanvasToPreset(800, 600)" style="font-size: 11px; padding: 5px;">800x600</button>
                        <button class="btn-secondary" onclick="resizeCanvasToPreset(1024, 768)" style="font-size: 11px; padding: 5px;">1024x768</button>
                        <button class="btn-secondary" onclick="resizeCanvasToPreset(1280, 720)" style="font-size: 11px; padding: 5px;">1280x720</button>
                        <button class="btn-secondary" onclick="resizeCanvasToPreset(1920, 1080)" style="font-size: 11px; padding: 5px;">1920x1080</button>
                        <button class="btn-secondary" onclick="resizeCanvasToPreset(2560, 1440)" style="font-size: 11px; padding: 5px;">2560x1440</button>
                        <button class="btn-secondary" onclick="resizeCanvasToPreset(1080, 1080)" style="font-size: 11px; padding: 5px;">1080x1080</button>
                    </div>
                </div>
            </div>
            <button class="btn-primary" onclick="applyResize()">Aplicar</button>
            <button class="btn-secondary" onclick="closeResizeModal()">Cancelar</button>
        </div>
    </div>

    <div id="filterModal" class="modal">
        <div class="modal-content">
            <h3>‚ú® Ajustar Filtro</h3>
            <label id="filterLabel">Intensidad:</label>
            <input type="range" id="filterIntensity" min="0" max="100" value="50">
            <span id="filterValue">50</span>
            <button class="btn-primary" onclick="applyFilterWithIntensity()">Aplicar</button>
            <button class="btn-secondary" onclick="closeFilterModal()">Cancelar</button>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <input type="file" id="fileInput" style="display: none;" accept="image/*" onchange="handleFileSelect(event)">

    <script>
        // Variables globales
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        let isDrawing = false;
        let currentTool = 'brush';
        let currentColor = '#000000';
        let currentColor2 = '#ffffff';
        let brushSize = 5;
        
        // Variables para funcionalidad de copiar/pegar
        let copiedImageData = null;
        
        // Variables para guardar/cargar proyecto
        let projectName = 'Sin t√≠tulo';
        let autoSaveEnabled = true;
        let autoSaveInterval = null;
        let opacity = 1.0;
        let fillStyle = 'none';
        let startX, startY;
        let history = [];
        let historyStep = -1;
        let maxHistory = 50;
        let zoom = 1.0;
        let brushType = 'round';
        let smoothing = 0;
        let spacing = 1;
        let symmetryMode = 'none';
        let gradientType = 'linear';
        let showGrid = false;
        let showRulers = false;
        let rulerUnit = 10; // pixeles por unidad de medida
        let gridSize = 20; // tama√±o de la cuadr√≠cula
        
        // Sistema de capas mejorado
        let layers = [{ 
            id: 1,
            name: 'Capa 1', 
            visible: true, 
            opacity: 1.0, 
            shapes: [],
            canvas: null,
            ctx: null
        }];
        let currentLayer = 0;
        let nextLayerId = 2;
        let textPosition = null;
        let selectionStart = null;
        let selectionEnd = null;
        let clipboard = null;
        
        // Variables para el sistema de selecci√≥n mejorado
        let activeSelection = null; // {x, y, width, height, imageData}
        let freeformPoints = []; // Para selecci√≥n de forma libre
        let transparentSelection = false; // Para selecci√≥n transparente
        let selectionImageData = null; // Datos de la imagen seleccionada
        let isMovingSelection = false; // Si se est√° moviendo la selecci√≥n
        let selectionOffsetX = 0;
        let selectionOffsetY = 0;
        let selectionOriginalX = 0; // Posici√≥n original X de la selecci√≥n
        let selectionOriginalY = 0; // Posici√≥n original Y de la selecci√≥n
        let selectionMoved = false; // Si la selecci√≥n fue movida desde su posici√≥n original
        let canvasBeforeSelection = null; // Copia del canvas antes de mover la selecci√≥n
        
        let points = [];
        let curvePoints = [];
        let cloneSource = null;
    let lastStampPoint = null; // Para pinceles basados en "dabs"
    let fillTolerance = 10; // Tolerancia para flood fill (ajustable)
    // Pan y entrada avanzada
    let spacePressed = false;
    let isPanning = false;
    let panStartX = 0, panStartY = 0, panScrollLeft = 0, panScrollTop = 0;
    let editingTextShape = null; // para editar texto existente

    // Estados de interacci√≥n para Pol√≠gono y Curva
    let polygonModeActive = false;
    let polygonPoints = [];
    let curvePhase = 0; // 0: inactivo, 1: arrastrando primer control, 2: primer control fijado, 3: arrastrando segundo control, 4: listo para finalizar
    let curveStart = null;
    let curveEnd = null;
    let curveCp1 = null; // primer punto de control
    let curveCp2 = null; // segundo punto de control
        
        // Variables para selecci√≥n y manipulaci√≥n de figuras
        let shapes = [];
        let shapesHistory = []; // Historial de estados de figuras
        let shapesHistoryStep = -1;
        let selectedShape = null;
        let isMoving = false;
        let isResizing = false;
        let isRotating = false;
        let moveOffsetX = 0;
        let moveOffsetY = 0;
        let lastClickedShapes = [];
        let initialDistance = 0;
        let initialAngle = 0;
        let rightClickHeld = false;
        let rotationAngle = 0; // Para mostrar el √°ngulo actual de rotaci√≥n
        
        // Paleta de colores predefinida
        const defaultPalette = [
            '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
            '#800000', '#808000', '#008000', '#008080', '#000080', '#800080', '#FFA500', '#FFC0CB',
            '#A52A2A', '#DEB887', '#5F9EA0', '#7FFF00', '#D2691E', '#FF7F50', '#6495ED', '#DC143C',
            '#00CED1', '#9400D3', '#FF1493', '#00BFFF', '#696969', '#1E90FF', '#B22222', '#228B22'
        ];

        // Inicializaci√≥n
        function init() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Inicializar sistema de capas
            initializeLayers();
            shapes = [...layers[0].shapes]; // Cargar figuras de la primera capa
            
            saveState();
            saveShapesState(); // Inicializar historial de figuras
            updateColorPalette();
            updateBrushPreview();
            updateMinimap();
            updateGradientPreview();
            updateLayersList();
            
            // Inicializar sistema de autoguardado
            enableAutoSave();
            
            // Verificar si hay un autoguardado previo
            setTimeout(() => {
                loadAutoSave();
                // Inicia una nueva sesi√≥n: a√∫n no se ha cerrado de forma "limpia"
                // Esto se usar√° para decidir si mostrar el di√°logo de recuperaci√≥n en el pr√≥ximo arranque
                try { localStorage.setItem('paintpro_last_exit_clean', 'false'); } catch(e) { /* ignore */ }
            }, 1000);
            
            // Actualizar t√≠tulo de la ventana
            updateWindowTitle();
            
            // Inicializar reglas y cuadr√≠cula (ocultas por defecto)
            const rulerH = document.getElementById('rulerHorizontal');
            const rulerV = document.getElementById('rulerVertical');
            const rulerC = document.getElementById('rulerCorner');
            const gridO = document.getElementById('gridOverlay');
            
            if (rulerH) rulerH.style.display = 'none';
            if (rulerV) rulerV.style.display = 'none';
            if (rulerC) rulerC.style.display = 'none';
            if (gridO) {
                gridO.style.display = 'none';
                // Configurar estilos iniciales del grid
                gridO.style.position = 'absolute';
                gridO.style.top = '0';
                gridO.style.left = '0';
                gridO.style.pointerEvents = 'none';
                gridO.style.zIndex = '10';
            }
            
            // Event listeners del canvas (mouse)
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('dblclick', handleCanvasDoubleClick);
            canvas.addEventListener('mousemove', updateCoordinates);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault(); // Prevenir men√∫ contextual
            });

            // Soporte de Pointer Events para evitar cortes al salir del canvas
            if (window.PointerEvent) {
                canvas.addEventListener('pointerdown', (e) => {
                    try { canvas.setPointerCapture(e.pointerId); } catch(_) {}
                    startDrawing(e);
                });
                canvas.addEventListener('pointermove', draw);
                canvas.addEventListener('pointerup', (e) => {
                    try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
                    stopDrawing(e);
                });
            }
            
            // Event listeners para drag & drop
            canvas.addEventListener('dragover', handleDragOver);
            canvas.addEventListener('dragleave', handleDragLeave);
            canvas.addEventListener('drop', handleFileDrop);
            
            // Event listeners globales para el documento
            document.addEventListener('mouseup', function(e) {
                if (isMoving || isRotating) {
                    if (selectedShape) {
                        selectedShape.selected = false;
                        redrawCanvasWithShapes();
                    }
                    
                    if (isRotating) {
                        hideRotationDisplay(); // Ocultar indicador al terminar rotaci√≥n
                    }
                    
                    isMoving = false;
                    isRotating = false;
                    selectedShape = null;
                    canvas.style.cursor = 'crosshair';
                }
                if (e.button === 2) {
                    rightClickHeld = false;
                    if (selectedShape && isResizing) {
                        selectedShape.selected = false;
                        redrawCanvasWithShapes();
                        isResizing = false;
                        selectedShape = null;
                        canvas.style.cursor = 'crosshair';
                    }
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if ((isMoving || isRotating) && selectedShape) {
                    const pos = getMousePos(e);
                    
                    if (isMoving) {
                        const deltaX = pos.x - moveOffsetX;
                        const deltaY = pos.y - moveOffsetY;
                        
                        moveShape(selectedShape, deltaX, deltaY);
                        moveOffsetX = pos.x;
                        moveOffsetY = pos.y;
                    } else if (isRotating) {
                        const centerX = selectedShape.type === 'brush' && selectedShape.centerX !== undefined ?
                            selectedShape.centerX :
                            (selectedShape.startX + selectedShape.endX) / 2;
                        const centerY = selectedShape.type === 'brush' && selectedShape.centerY !== undefined ?
                            selectedShape.centerY :
                            (selectedShape.startY + selectedShape.endY) / 2;
                        
                        const currentAngle = getAngle(centerX, centerY, pos.x, pos.y);
                        const angleChange = currentAngle - initialAngle;
                        
                        rotateShape(selectedShape, angleChange);
                        initialAngle = currentAngle;
                    }
                    
                    redrawCanvasWithShapes();
                }
                // Pan mientras se mantiene Space o bot√≥n central
                if (isPanning) {
                    const area = document.getElementById('canvasArea');
                    area.scrollLeft = panScrollLeft - (e.clientX - panStartX);
                    area.scrollTop = panScrollTop - (e.clientY - panStartY);
                }
            });

            // Marcar cierre "limpio" cuando la pesta√±a/ventana se est√° cerrando o recargando
            // Si el navegador se cierra inesperadamente, este evento no se dispara y en el pr√≥ximo arranque
            // podremos ofrecer recuperar el autoguardado solo en ese caso.
            window.addEventListener('beforeunload', () => {
                try { localStorage.setItem('paintpro_last_exit_clean', 'true'); } catch(e) { /* ignore */ }
            });

            // Pan: eventos de mouse en el √°rea de canvas
            const area = document.getElementById('canvasArea');
            area.addEventListener('mousedown', (e) => {
                if (spacePressed || e.button === 1) {
                    isPanning = true;
                    panStartX = e.clientX; panStartY = e.clientY;
                    panScrollLeft = area.scrollLeft; panScrollTop = area.scrollTop;
                    area.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });
            document.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    area.style.cursor = '';
                }
            });
            // Space para pan
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !spacePressed && !e.repeat) {
                    // Evitar scroll de p√°gina
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        spacePressed = true; area.style.cursor = 'grab';
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') { spacePressed = false; area.style.cursor = ''; }
            });
            
            // Actualizar tama√±o de archivo
            updateFileSize();
            
            // Asegurar que el estado inicial de la cuadr√≠cula sea correcto
            const gridBtn = document.getElementById('gridBtn');
            if (gridBtn && !showGrid) {
                gridBtn.classList.remove('active');
                gridBtn.style.backgroundColor = '';
                gridBtn.style.color = '';
            }

            // Desactivar suavizado para un renderizado m√°s n√≠tido (√∫til para l√°piz pixel-art)
            if (ctx.imageSmoothingEnabled !== undefined) {
                ctx.imageSmoothingEnabled = false;
            }
        }

        function startDrawing(e) {
            if (spacePressed) return; // no dibujar mientras se hace pan con Space
            const pos = getMousePos(e);
            
            // Prevenir men√∫ contextual en click derecho
            if (e.button === 2) {
                e.preventDefault();
                rightClickHeld = true;
                return;
            }
            
            // Manejar selecci√≥n y manipulaci√≥n de figuras con modificadores
            if (e.button === 0) { // Click izquierdo
                if (e.ctrlKey) {
                    // Modo mover
                    const shapeToMove = selectBestShapeAtPosition(pos.x, pos.y);
                    
                    if (shapeToMove) {
                        saveShapesState(); // Guardar estado antes de mover
                        shapes.forEach(shape => shape.selected = false);
                        
                        selectedShape = shapeToMove;
                        selectedShape.selected = true;
                        isMoving = true;
                        moveOffsetX = pos.x;
                        moveOffsetY = pos.y;
                        canvas.style.cursor = 'move';
                        redrawCanvasWithShapes();
                        showNotification('Figura seleccionada para mover (mant√©n Ctrl + arrastra)');
                    }
                    return;
                } else if (e.shiftKey) {
                    // Modo rotar
                    const shapeToRotate = selectBestShapeAtPosition(pos.x, pos.y);
                    
                    if (shapeToRotate) {
                        saveShapesState(); // Guardar estado antes de rotar
                        shapes.forEach(shape => shape.selected = false);
                        
                        selectedShape = shapeToRotate;
                        selectedShape.selected = true;
                        isRotating = true;
                        
                        const centerX = shapeToRotate.type === 'brush' && shapeToRotate.centerX !== undefined ?
                            shapeToRotate.centerX :
                            (shapeToRotate.startX + shapeToRotate.endX) / 2;
                        const centerY = shapeToRotate.type === 'brush' && shapeToRotate.centerY !== undefined ?
                            shapeToRotate.centerY :
                            (shapeToRotate.startY + shapeToRotate.endY) / 2;
                        
                        initialAngle = getAngle(centerX, centerY, pos.x, pos.y);
                        canvas.style.cursor = 'grab';
                        
                        // Inicializar el √°ngulo de rotaci√≥n y mostrar el indicador
                        rotationAngle = (shapeToRotate.rotation || 0) * (180 / Math.PI);
                        updateRotationDisplay();
                        
                        redrawCanvasWithShapes();
                        showNotification('Figura seleccionada para rotar (mant√©n Shift + arrastra)');
                    }
                    return;
                }
            }
            
            // Limpiar selecciones previas si no se est√° manipulando
            shapes.forEach(shape => shape.selected = false);

            // Interacci√≥n POL√çGONO
            if (currentTool === 'polygon') {
                // Iniciar o agregar punto
                if (!polygonModeActive) {
                    saveShapesState();
                    polygonModeActive = true;
                    polygonPoints = [ { x: pos.x, y: pos.y } ];
                    showNotification('Pol√≠gono: click para agregar v√©rtices, doble click o Enter para cerrar, Esc para cancelar');
                } else {
                    polygonPoints.push({ x: pos.x, y: pos.y });
                }
                redrawCanvasWithShapes();
                // Vista previa se dibuja en draw() con el mousemove
                return;
            }

            // Interacci√≥n CURVA (estilo Paint: B√©zier c√∫bica con arrastre)
            if (currentTool === 'curve') {
                if (curvePhase === 0) {
                    // Primer click: inicio de la curva
                    saveShapesState();
                    curveStart = { x: pos.x, y: pos.y };
                    curvePhase = 1; // siguiente click fija el final y entra en modo arrastre
                    isDrawing = true; // para detectar arrastre
                    showNotification('Curva: arrastra para definir curvatura inicial, suelta y arrastra de nuevo para el final');
                } else if (curvePhase === 2) {
                    // Segundo click: fin de la curva, ahora ajustando el segundo control
                    curveEnd = { x: pos.x, y: pos.y };
                    curvePhase = 3; // ajuste del segundo punto de control
                    isDrawing = true;
                } else if (curvePhase === 4) {
                    // Finalizar la curva (ya se solt√≥ el segundo control)
                    curvePhase = 0;
                    curveStart = null;
                    curveEnd = null;
                    isDrawing = false;
                    redrawCanvasWithShapes();
                    saveState();
                    showNotification('Curva creada');
                }
                return;
            }
            
            if (currentTool === 'text') {
                // Si clic en texto existente: editar; si no: nuevo
                const shapeToEdit = selectBestShapeAtPosition(pos.x, pos.y);
                if (shapeToEdit && shapeToEdit.type === 'text') {
                    openTextModal(shapeToEdit);
                } else {
                    textPosition = pos;
                    openTextModal(null);
                }
                return;
            }

            if (currentTool === 'eyedropper') {
                pickColor(pos, e);
                return;
            }

            if (currentTool === 'fill') {
                floodFill(pos);
                return;
            }

            if (currentTool === 'select') {
                // Verificar si se hizo click dentro de una selecci√≥n existente para moverla
                if (activeSelection && isPointInSelection(pos.x, pos.y)) {
                    isMovingSelection = true;
                    selectionOffsetX = pos.x - activeSelection.x;
                    selectionOffsetY = pos.y - activeSelection.y;
                    canvas.style.cursor = 'move';
                    
                    // Si es la primera vez que se mueve, limpiar el √°rea original
                    if (!selectionMoved && canvasBeforeSelection) {
                        // Restaurar el canvas y luego limpiar solo el √°rea de la selecci√≥n
                        ctx.putImageData(canvasBeforeSelection, 0, 0);
                        
                        // Limpiar el √°rea original de la selecci√≥n
                        const bgColor = backgroundState && backgroundState.color ? backgroundState.color : '#ffffff';
                        if (backgroundState && backgroundState.type === 'transparent') {
                            ctx.clearRect(selectionOriginalX, selectionOriginalY, activeSelection.width, activeSelection.height);
                        } else {
                            ctx.fillStyle = bgColor;
                            ctx.fillRect(selectionOriginalX, selectionOriginalY, activeSelection.width, activeSelection.height);
                        }
                        
                        selectionMoved = true;
                    }
                    return;
                }
                // Si no, iniciar nueva selecci√≥n
                selectionStart = pos;
                activeSelection = null;
                selectionMoved = false;
                return;
            }

            if (currentTool === 'freeformSelect') {
                // Verificar si se hizo click dentro de una selecci√≥n existente para moverla
                if (activeSelection && isPointInSelection(pos.x, pos.y)) {
                    isMovingSelection = true;
                    selectionOffsetX = pos.x - activeSelection.x;
                    selectionOffsetY = pos.y - activeSelection.y;
                    canvas.style.cursor = 'move';
                    
                    // Si es la primera vez que se mueve, limpiar el √°rea original
                    if (!selectionMoved && canvasBeforeSelection) {
                        ctx.putImageData(canvasBeforeSelection, 0, 0);
                        
                        const bgColor = backgroundState && backgroundState.color ? backgroundState.color : '#ffffff';
                        if (backgroundState && backgroundState.type === 'transparent') {
                            ctx.clearRect(selectionOriginalX, selectionOriginalY, activeSelection.width, activeSelection.height);
                        } else {
                            ctx.fillStyle = bgColor;
                            ctx.fillRect(selectionOriginalX, selectionOriginalY, activeSelection.width, activeSelection.height);
                        }
                        
                        selectionMoved = true;
                    }
                    return;
                }
                // Si no, iniciar nueva selecci√≥n libre
                freeformPoints = [pos];
                isDrawing = true;
                selectionMoved = false;
                return;
            }

            if (currentTool === 'clone' && e.ctrlKey) {
                cloneSource = pos;
                showNotification('Fuente de clonado establecida');
                return;
            }

            saveShapesState(); // Guardar estado antes de dibujar
            isDrawing = true;
            startX = pos.x;
            startY = pos.y;
            points = [pos];

            ctx.globalAlpha = opacity;

            if (currentTool === 'brush' || currentTool === 'pencil' || currentTool === 'eraser' || currentTool === 'spray') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            }
            // Nota: la l√≥gica interactiva de pol√≠gono/curva se maneja arriba.
        }

        function draw(e) {
            const pos = getMousePos(e);
            
            // Manejar movimiento de selecci√≥n
            if (isMovingSelection && activeSelection && selectionImageData) {
                // Calcular nueva posici√≥n
                const newX = pos.x - selectionOffsetX;
                const newY = pos.y - selectionOffsetY;
                
                // Actualizar posici√≥n de la selecci√≥n
                activeSelection.x = newX;
                activeSelection.y = newY;
                
                // Redibujar canvas limpio + selecci√≥n flotante
                redrawCanvasWithShapes();
                drawFloatingSelection();
                return;
            }
            
            // Manejar movimiento de figuras
            if (isMoving && selectedShape) {
                const deltaX = pos.x - moveOffsetX;
                const deltaY = pos.y - moveOffsetY;
                
                moveShape(selectedShape, deltaX, deltaY);
                moveOffsetX = pos.x;
                moveOffsetY = pos.y;
                redrawCanvasWithShapes();
                return;
            }
            
            // Manejar rotaci√≥n de figuras
            if (isRotating && selectedShape) {
                const centerX = selectedShape.type === 'brush' && selectedShape.centerX !== undefined ?
                    selectedShape.centerX :
                    (selectedShape.startX + selectedShape.endX) / 2;
                const centerY = selectedShape.type === 'brush' && selectedShape.centerY !== undefined ?
                    selectedShape.centerY :
                    (selectedShape.startY + selectedShape.endY) / 2;
                
                const currentAngle = getAngle(centerX, centerY, pos.x, pos.y);
                const angleChange = currentAngle - initialAngle;
                
                rotateShape(selectedShape, angleChange);
                initialAngle = currentAngle;
                redrawCanvasWithShapes();
                return;
            }
            
            if (currentTool === 'select' && selectionStart) {
                drawSelection(selectionStart, pos);
            }

            // Dibujar selecci√≥n de forma libre
            if (currentTool === 'freeformSelect' && isDrawing) {
                freeformPoints.push(pos);
                redrawCanvasWithShapes();
                drawFreeformSelection();
            }

            // Vista previa de POL√çGONO
            if (currentTool === 'polygon' && polygonModeActive && polygonPoints.length > 0) {
                redrawCanvasWithShapes();
                ctx.save();
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                for (let i = 1; i < polygonPoints.length; i++) {
                    ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
                }
                // l√≠nea temporal hacia el cursor
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
                return;
            }

            // Vista previa de CURVA (estilo Paint con B√©zier c√∫bica)
            if (currentTool === 'curve' && curvePhase > 0) {
                redrawCanvasWithShapes();
                ctx.save();
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                
                if (curvePhase === 1 && isDrawing) {
                    // Arrastrando desde el punto inicial para definir direcci√≥n/curvatura inicial
                    // L√≠nea recta temporal y primer punto de control
                    curveCp1 = { x: pos.x, y: pos.y };
                    ctx.beginPath();
                    ctx.moveTo(curveStart.x, curveStart.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.strokeStyle = '#14FFEC';
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    // Dibujar manija
                    ctx.fillStyle = '#14FFEC';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (curvePhase === 2) {
                    // Esperando segundo click (mostrar l√≠nea desde start hacia cursor)
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(curveStart.x, curveStart.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (curvePhase === 3 && isDrawing) {
                    // Arrastrando el segundo punto de control
                    curveCp2 = { x: pos.x, y: pos.y };
                    // Dibujar la curva B√©zier c√∫bica completa
                    ctx.beginPath();
                    ctx.moveTo(curveStart.x, curveStart.y);
                    ctx.bezierCurveTo(curveCp1.x, curveCp1.y, pos.x, pos.y, curveEnd.x, curveEnd.y);
                    ctx.stroke();
                    // Dibujar manijas de control
                    ctx.strokeStyle = '#14FFEC';
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(curveStart.x, curveStart.y);
                    ctx.lineTo(curveCp1.x, curveCp1.y);
                    ctx.moveTo(curveEnd.x, curveEnd.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#14FFEC';
                    ctx.beginPath();
                    ctx.arc(curveCp1.x, curveCp1.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                return;
            }

            if (!isDrawing) return;

            // Para herramientas de formas geom√©tricas, mostrar vista previa
            if (['line', 'rectangle', 'circle', 'triangle', 'star', 'arrow'].includes(currentTool)) {
                // Redibujar canvas con todas las figuras guardadas
                redrawCanvasWithShapes();
                
                // Dibujar vista previa de la figura actual
                const originalStrokeStyle = ctx.strokeStyle;
                const originalLineWidth = ctx.lineWidth;
                
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                
                switch(currentTool) {
                    case 'line':
                        drawLine(startX, startY, pos.x, pos.y);
                        break;
                    case 'rectangle':
                        drawRectangle(startX, startY, pos.x, pos.y);
                        break;
                    case 'circle':
                        drawCircle(startX, startY, pos.x, pos.y);
                        break;
                    case 'triangle':
                        drawTriangle(startX, startY, pos.x, pos.y);
                        break;
                    case 'star':
                        drawStar(startX, startY, pos.x, pos.y);
                        break;
                    case 'arrow':
                        drawArrow(startX, startY, pos.x, pos.y);
                        break;
                }
                
                ctx.strokeStyle = originalStrokeStyle;
                ctx.lineWidth = originalLineWidth;
            } else {
                // Para herramientas de dibujo libre
                switch(currentTool) {
                    case 'brush':
                        drawBrush(pos);
                        break;
                    case 'pencil':
                        drawPencil(pos);
                        break;
                    case 'spray':
                        drawSpray(pos);
                        break;
                    case 'eraser':
                        drawEraser(pos);
                        break;
                    case 'clone':
                        drawClone(pos);
                        break;
                    case 'blur':
                        drawBlur(pos);
                        break;
                }
            }
            
            applySymmetry(pos);
        }

        function stopDrawing(e) {
            const pos = getMousePos(e);
            
            // Finalizar movimiento de selecci√≥n
            if (isMovingSelection) {
                isMovingSelection = false;
                canvas.style.cursor = 'crosshair';
                
                // Pegar la imagen en la nueva posici√≥n permanentemente
                if (selectionImageData && selectionMoved) {
                    // La imagen ya est√° dibujada en el canvas, solo necesitamos guardar el estado
                    ctx.putImageData(selectionImageData, activeSelection.x, activeSelection.y);
                    saveShapesState(); // Guardar para undo
                    
                    // Convertir el canvas actual a una imagen y agregarlo a las formas
                    const img = new Image();
                    img.onload = function() {
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = canvas.width;
                        tempCanvas.height = canvas.height;
                        tempCtx.drawImage(canvas, 0, 0);
                        const imageData = tempCanvas.toDataURL('image/png');
                        
                        shapes.push({
                            type: 'image',
                            x: 0,
                            y: 0,
                            width: canvas.width,
                            height: canvas.height,
                            image: img,
                            imageData: imageData,
                            selected: false
                        });
                        
                        redrawCanvasWithShapes();
                        drawActiveSelection(); // Redibujar marco
                    };
                    img.src = canvas.toDataURL();
                }
                
                showNotification('Selecci√≥n colocada. Ctrl+C para copiar, Supr para eliminar, click fuera para nueva selecci√≥n', 'info');
                return;
            }
            
            // Manejar transiciones de fase de CURVA estilo Paint
            if (currentTool === 'curve' && curvePhase > 0) {
                if (curvePhase === 1 && isDrawing) {
                    // Soltar primer arrastre: fija curveCp1 y pasa a fase 2 (esperar click en final)
                    curveCp1 = { x: pos.x, y: pos.y };
                    curvePhase = 2;
                    isDrawing = false;
                    redrawCanvasWithShapes();
                    return;
                } else if (curvePhase === 3 && isDrawing) {
                    // Soltar segundo arrastre: fija curveCp2 y crea la figura
                    curveCp2 = { x: pos.x, y: pos.y };
                    shapes.push({
                        type: 'curve',
                        startX: curveStart.x,
                        startY: curveStart.y,
                        endX: curveEnd.x,
                        endY: curveEnd.y,
                        cp1x: curveCp1.x,
                        cp1y: curveCp1.y,
                        cp2x: curveCp2.x,
                        cp2y: curveCp2.y,
                        color: currentColor,
                        lineWidth: brushSize,
                        selected: false,
                        rotation: 0
                    });
                    curvePhase = 0;
                    curveStart = null;
                    curveEnd = null;
                    curveCp1 = null;
                    curveCp2 = null;
                    isDrawing = false;
                    redrawCanvasWithShapes();
                    saveState();
                    showNotification('Curva B√©zier creada');
                    return;
                }
            }
            
            // Manejar click derecho para escalado
            if (e.button === 2) {
                rightClickHeld = false;
                if (selectedShape && isResizing) {
                    selectedShape.selected = false;
                    redrawCanvasWithShapes();
                    isResizing = false;
                    selectedShape = null;
                    canvas.style.cursor = 'crosshair';
                }
                return;
            }
            
            // Finalizar movimiento de figuras
            if (isMoving) {
                if (selectedShape) {
                    selectedShape.selected = false;
                    redrawCanvasWithShapes();
                }
                isMoving = false;
                selectedShape = null;
                canvas.style.cursor = 'crosshair';
                showNotification('Figura movida');
                return;
            }
            
            // Finalizar rotaci√≥n de figuras
            if (isRotating) {
                if (selectedShape) {
                    selectedShape.selected = false;
                    redrawCanvasWithShapes();
                }
                isRotating = false;
                selectedShape = null;
                canvas.style.cursor = 'crosshair';
                hideRotationDisplay(); // Ocultar el indicador de √°ngulo
                showNotification('Figura rotada');
                return;
            }
            
            if (!isDrawing) return;
            isDrawing = false;

            ctx.globalAlpha = opacity;

            // Guardar las figuras creadas en el array shapes
            switch(currentTool) {
                case 'line':
                    shapes.push({
                        type: 'line',
                        startX: startX,
                        startY: startY,
                        endX: pos.x,
                        endY: pos.y,
                        color: currentColor,
                        lineWidth: brushSize,
                        selected: false,
                        rotation: 0
                    });
                    redrawCanvasWithShapes(); // Redibujar con la nueva figura
                    break;
                case 'rectangle':
                    shapes.push({
                        type: 'rectangle',
                        startX: startX,
                        startY: startY,
                        endX: pos.x,
                        endY: pos.y,
                        color: currentColor,
                        lineWidth: brushSize,
                        selected: false,
                        rotation: 0
                    });
                    redrawCanvasWithShapes(); // Redibujar con la nueva figura
                    break;
                case 'circle':
                    shapes.push({
                        type: 'circle',
                        startX: startX,
                        startY: startY,
                        endX: pos.x,
                        endY: pos.y,
                        color: currentColor,
                        lineWidth: brushSize,
                        selected: false,
                        rotation: 0
                    });
                    redrawCanvasWithShapes(); // Redibujar con la nueva figura
                    break;
                case 'triangle':
                    shapes.push({
                        type: 'triangle',
                        startX: startX,
                        startY: startY,
                        endX: pos.x,
                        endY: pos.y,
                        color: currentColor,
                        lineWidth: brushSize,
                        selected: false,
                        rotation: 0
                    });
                    redrawCanvasWithShapes(); // Redibujar con la nueva figura
                    break;
                case 'star':
                    shapes.push({
                        type: 'star',
                        startX: startX,
                        startY: startY,
                        endX: pos.x,
                        endY: pos.y,
                        color: currentColor,
                        lineWidth: brushSize,
                        selected: false,
                        rotation: 0
                    });
                    redrawCanvasWithShapes(); // Redibujar con la nueva figura
                    break;
                case 'arrow':
                    shapes.push({
                        type: 'arrow',
                        startX: startX,
                        startY: startY,
                        endX: pos.x,
                        endY: pos.y,
                        color: currentColor,
                        lineWidth: brushSize,
                        selected: false,
                        rotation: 0
                    });
                    redrawCanvasWithShapes(); // Redibujar con la nueva figura
                    break;
                case 'brush':
                    if (points && points.length > 0) {
                        const center = calculateBrushCenter(points);
                        shapes.push({
                            type: 'brush',
                            points: [...points],
                            centerX: center.x,
                            centerY: center.y,
                            color: currentColor,
                            lineWidth: brushSize,
                            selected: false,
                            rotation: 0
                        });
                        redrawCanvasWithShapes(); // Redibujar con la nueva figura
                    }
                    lastStampPoint = null; // reset de pincel estampado
                    break;
                case 'pencil':
                    if (points && points.length > 0) {
                        const center = calculateBrushCenter(points);
                        shapes.push({
                            type: 'pencil',
                            points: [...points],
                            centerX: center.x,
                            centerY: center.y,
                            color: currentColor,
                            lineWidth: 1,
                            selected: false,
                            rotation: 0
                        });
                        redrawCanvasWithShapes(); // Redibujar con la nueva figura
                    }
                    break;
                case 'gradient':
                    drawGradient(startX, startY, pos.x, pos.y);
                    break;
                case 'select':
                    // Crear selecci√≥n rectangular
                    if (selectionStart && pos) {
                        const x = Math.min(selectionStart.x, pos.x);
                        const y = Math.min(selectionStart.y, pos.y);
                        const width = Math.abs(pos.x - selectionStart.x);
                        const height = Math.abs(pos.y - selectionStart.y);
                        
                        if (width > 5 && height > 5) {
                            activeSelection = { x, y, width, height };
                            captureSelection();
                            selectionEnd = pos;
                            redrawCanvasWithShapes();
                            drawActiveSelection();
                            showNotification('√Årea seleccionada (Ctrl+C para copiar, Supr para eliminar)', 'success');
                        } else {
                            clearSelection();
                        }
                    }
                    break;
                case 'freeformSelect':
                    // Finalizar selecci√≥n de forma libre
                    finalizeFreeformSelection();
                    break;
                // Las herramientas pol√≠gono/curva se manejan de forma interactiva y no se comprometen aqu√≠
            }

            ctx.globalAlpha = 1.0;
            saveState();
            updateMinimap();
            updateFileSize();
        }

        function drawBrush(pos) {
            // Pincel basado en "dabs" (sellos) con espaciamiento
            const step = Math.max(1, brushSize * (spacing / 10));
            if (!lastStampPoint) {
                lastStampPoint = { x: startX, y: startY };
            }
            const dx = pos.x - lastStampPoint.x;
            const dy = pos.y - lastStampPoint.y;
            const dist = Math.hypot(dx, dy);
            const steps = Math.max(1, Math.floor(dist / step));
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const x = lastStampPoint.x + dx * t;
                const y = lastStampPoint.y + dy * t;
                stampBrush(x, y);
                // Registrar punto para reconstrucci√≥n del trazo como figura
                points.push({ x, y });
            }
            lastStampPoint = { x: pos.x, y: pos.y };
        }

        function drawPencil(pos) {
            // L√°piz pixel-perfect: pinta p√≠xeles 1x1 usando Bresenham
            const last = points.length ? points[points.length - 1] : { x: startX, y: startY };
            plotLine(Math.floor(last.x), Math.floor(last.y), Math.floor(pos.x), Math.floor(pos.y), (x, y) => {
                ctx.fillStyle = currentColor;
                ctx.fillRect(x, y, 1, 1);
            });
            points.push({ x: pos.x, y: pos.y });
        }

        function plotLine(x0, y0, x1, y1, drawPixel) {
            let dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
            let dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1; 
            let err = dx + dy, e2;
            while (true) {
                drawPixel(x0, y0);
                if (x0 === x1 && y0 === y1) break;
                e2 = 2 * err;
                if (e2 >= dy) { err += dy; x0 += sx; }
                if (e2 <= dx) { err += dx; y0 += sy; }
            }
        }

        function stampBrush(x, y) {
            ctx.save();
            ctx.globalAlpha = opacity;
            switch (brushType) {
                case 'square': {
                    const s = brushSize;
                    ctx.fillStyle = currentColor;
                    ctx.fillRect(x - s/2, y - s/2, s, s);
                    break;
                }
                case 'soft': {
                    const r = brushSize / 2;
                    const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                    const col = currentColor;
                    g.addColorStop(0, col);
                    g.addColorStop(1, col + '00');
                    ctx.fillStyle = g;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                }
                case 'calligraphy': {
                    const rx = brushSize;
                    const ry = Math.max(1, brushSize / 3);
                    ctx.fillStyle = currentColor;
                    ctx.beginPath();
                    ctx.ellipse(x, y, rx/2, ry/2, 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                }
                case 'spray': {
                    // reutiliza spray existente
                    drawSpray({ x, y });
                    break;
                }
                case 'pattern': {
                    const p = document.createElement('canvas');
                    p.width = p.height = Math.max(4, Math.floor(brushSize/2));
                    const pctx = p.getContext('2d');
                    pctx.fillStyle = currentColor;
                    pctx.fillRect(0, 0, p.width, p.height);
                    pctx.clearRect(p.width/2, 0, p.width/2, p.height/2);
                    const pattern = ctx.createPattern(p, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.beginPath();
                    ctx.arc(x, y, brushSize/2, 0, Math.PI*2);
                    ctx.fill();
                    break;
                }
                default: {
                    // round por defecto
                    ctx.fillStyle = currentColor;
                    ctx.beginPath();
                    ctx.arc(x, y, brushSize/2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
        }

        function drawSpray(pos) {
            const density = brushSize * 2;
            for (let i = 0; i < density; i++) {
                const offsetX = (Math.random() - 0.5) * brushSize * 2;
                const offsetY = (Math.random() - 0.5) * brushSize * 2;
                ctx.fillStyle = currentColor;
                ctx.fillRect(pos.x + offsetX, pos.y + offsetY, 1, 1);
            }
        }

        function drawEraser(pos) {
            // Borrador que elimina p√≠xeles (transparente si no hay fondo)
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            ctx.restore();
        }

        function drawLine(x1, y1, x2, y2, rotation = 0) {
            ctx.save();
            if (rotation !== 0) {
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation);
                ctx.translate(-centerX, -centerY);
            }
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }

        function drawRectangle(x1, y1, x2, y2, rotation = 0, style = {}) {
            ctx.save();
            if (rotation !== 0) {
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation);
                ctx.translate(-centerX, -centerY);
            }
            const x = Math.min(x1, x2);
            const y = Math.min(y1, y2);
            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);
            
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            if (style.fill) ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawCircle(x1, y1, x2, y2, rotation = 0, style = {}) {
            // Para c√≠rculos, mantener proporci√≥n 1:1
            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);
            const size = Math.min(width, height);
            const dirX = x2 >= x1 ? 1 : -1;
            const dirY = y2 >= y1 ? 1 : -1;
            const newX2 = x1 + dirX * size;
            const newY2 = y1 + dirY * size;
            
            const centerX = (x1 + newX2) / 2;
            const centerY = (y1 + newY2) / 2;
            const radius = size / 2;
            
            ctx.save();
            if (rotation !== 0) {
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation);
                ctx.translate(-centerX, -centerY);
            }
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            if (style.fill) ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawEllipse(x1, y1, x2, y2, rotation = 0, style = {}) {
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            const radiusX = Math.abs((x2 - x1) / 2);
            const radiusY = Math.abs((y2 - y1) / 2);
            
            ctx.save();
            if (rotation !== 0) {
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation);
                ctx.translate(-centerX, -centerY);
            }
            ctx.beginPath();
            if (ctx.ellipse) {
                ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            } else {
                // Fallback para navegadores que no soportan ellipse
                ctx.scale(1, radiusY/radiusX);
                ctx.arc(centerX, centerY * radiusX/radiusY, radiusX, 0, 2 * Math.PI);
            }
            if (style.fill) ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawTriangle(x1, y1, x2, y2, rotation = 0, style = {}) {
            const left = Math.min(x1, x2);
            const right = Math.max(x1, x2);
            const top = Math.min(y1, y2);
            const bottom = Math.max(y1, y2);
            const centerX = (left + right) / 2;
            
            ctx.save();
            if (rotation !== 0) {
                const cX = (x1 + x2) / 2;
                const cY = (y1 + y2) / 2;
                ctx.translate(cX, cY);
                ctx.rotate(rotation);
                ctx.translate(-cX, -cY);
            }
            
            ctx.beginPath();
            ctx.moveTo(centerX, top);     // Punta superior
            ctx.lineTo(right, bottom);    // Esquina inferior derecha
            ctx.lineTo(left, bottom);     // Esquina inferior izquierda
            ctx.closePath();
            
            if (style.fill) ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawStar(x1, y1, x2, y2, rotation = 0, style = {}) {
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) / 2;
            const spikes = 5;
            const outerRadius = radius;
            const innerRadius = radius / 2;
            
            ctx.save();
            if (rotation !== 0) {
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation);
                ctx.translate(-centerX, -centerY);
            }
            
            ctx.beginPath();
            for (let i = 0; i < spikes * 2; i++) {
                const angle = (Math.PI / spikes) * i;
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                const x = centerX + Math.cos(angle - Math.PI / 2) * r;
                const y = centerY + Math.sin(angle - Math.PI / 2) * r;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            
            if (style.fill) ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        function drawArrow(x1, y1, x2, y2, rotation = 0) {
            ctx.save();
            if (rotation !== 0) {
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation);
                ctx.translate(-centerX, -centerY);
            }
            
            const headLength = 20;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            // L√≠nea principal
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Punta de la flecha
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
            
            ctx.restore();
        }

        function drawGradient(x1, y1, x2, y2) {
            // Persistir el gradiente como fondo para que no desaparezca al redibujar
            let radius = 0;
            if (gradientType === 'radial') {
                radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }

            // Asegurar que exista el estado de fondo global
            if (typeof backgroundState === 'undefined') {
                window.backgroundState = { type: 'color', color: '#ffffff' };
            }

            backgroundState = {
                type: 'gradient',
                gradientType: gradientType,
                x1, y1, x2, y2,
                radius,
                color1: currentColor,
                color2: currentColor2
            };

            // Guardar en historial y redibujar
            saveShapesState();
            redrawCanvasWithShapes();
            showNotification('Gradiente aplicado como fondo');
        }

        function drawClone(pos) {
            if (!cloneSource) {
                showNotification('Presiona Ctrl + Click para establecer fuente');
                return;
            }
            
            const offsetX = pos.x - startX;
            const offsetY = pos.y - startY;
            
            const sourceX = cloneSource.x + offsetX;
            const sourceY = cloneSource.y + offsetY;
            
            const size = brushSize * 2;
            const imageData = ctx.getImageData(sourceX - size/2, sourceY - size/2, size, size);
            ctx.putImageData(imageData, pos.x - size/2, pos.y - size/2);
        }

        function drawBlur(pos) {
            const size = brushSize * 2;
            const imageData = ctx.getImageData(pos.x - size/2, pos.y - size/2, size, size);
            const pixels = imageData.data;
            
            for (let i = 0; i < pixels.length; i += 4) {
                if (i % (size * 4) !== 0) {
                    pixels[i] = (pixels[i] + pixels[i-4]) / 2;
                    pixels[i+1] = (pixels[i+1] + pixels[i-3]) / 2;
                    pixels[i+2] = (pixels[i+2] + pixels[i-2]) / 2;
                }
            }
            
            ctx.putImageData(imageData, pos.x - size/2, pos.y - size/2);
        }

        function applySymmetry(pos) {
            if (symmetryMode === 'none' || !isDrawing) return;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.save();
            
            if (symmetryMode === 'horizontal' || symmetryMode === 'both') {
                const mirrorX = centerX - (pos.x - centerX);
                drawSymmetryPoint(mirrorX, pos.y);
            }
            
            if (symmetryMode === 'vertical' || symmetryMode === 'both') {
                const mirrorY = centerY - (pos.y - centerY);
                drawSymmetryPoint(pos.x, mirrorY);
            }
            
            if (symmetryMode === 'both') {
                const mirrorX = centerX - (pos.x - centerX);
                const mirrorY = centerY - (pos.y - centerY);
                drawSymmetryPoint(mirrorX, mirrorY);
            }
            
            ctx.restore();
        }

        function drawSymmetryPoint(x, y) {
            ctx.fillStyle = currentColor;
            ctx.fillRect(x - brushSize/2, y - brushSize/2, brushSize, brushSize);
        }

        function floodFill(pos) {
            const x = Math.floor(pos.x);
            const y = Math.floor(pos.y);
            
            // Capturar estado actual del canvas antes del fill
            const beforeCanvas = document.createElement('canvas');
            beforeCanvas.width = canvas.width;
            beforeCanvas.height = canvas.height;
            const beforeCtx = beforeCanvas.getContext('2d');
            beforeCtx.drawImage(canvas, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const targetColor = getPixelColor(imageData, x, y);
            const fillColor = hexToRgb(currentColor);
            
            if (colorsMatch(targetColor, fillColor)) return;
            
            const stack = [[x, y]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [currentX, currentY] = stack.pop();
                const key = `${currentX},${currentY}`;
                
                if (visited.has(key)) continue;
                if (currentX < 0 || currentX >= canvas.width || currentY < 0 || currentY >= canvas.height) continue;
                
                const currentColor = getPixelColor(imageData, currentX, currentY);
                
                if (!colorsMatch(currentColor, targetColor)) continue;
                
                visited.add(key);
                setPixelColor(imageData, currentX, currentY, fillColor);
                
                stack.push([currentX + 1, currentY]);
                stack.push([currentX - 1, currentY]);
                stack.push([currentX, currentY + 1]);
                stack.push([currentX, currentY - 1]);
            }
            
            // Crear canvas temporal con el resultado del fill
            const fillCanvas = document.createElement('canvas');
            fillCanvas.width = canvas.width;
            fillCanvas.height = canvas.height;
            const fillCtx = fillCanvas.getContext('2d');
            fillCtx.putImageData(imageData, 0, 0);
            
            // Convertir a base64 para persistencia
            const imageDataURL = fillCanvas.toDataURL('image/png');
            
            // Guardar como figura de tipo imagen para que persista en redraw
            const img = new Image();
            img.onload = function() {
                saveShapesState();
                shapes.push({
                    type: 'image',
                    x: 0,
                    y: 0,
                    width: canvas.width,
                    height: canvas.height,
                    image: img,
                    imageData: imageDataURL, // Guardar base64 para persistencia
                    selected: false,
                    rotation: 0
                });
                redrawCanvasWithShapes();
                saveState();
                showNotification('√Årea rellenada');
            };
            img.src = imageDataURL;
        }

        function getPixelColor(imageData, x, y) {
            const index = (y * imageData.width + x) * 4;
            return {
                r: imageData.data[index],
                g: imageData.data[index + 1],
                b: imageData.data[index + 2],
                a: imageData.data[index + 3]
            };
        }

        function setPixelColor(imageData, x, y, color) {
            const index = (y * imageData.width + x) * 4;
            imageData.data[index] = color.r;
            imageData.data[index + 1] = color.g;
            imageData.data[index + 2] = color.b;
            imageData.data[index + 3] = 255;
        }

        function colorsMatch(c1, c2) {
            const tol = Math.max(0, Number(fillTolerance) || 0);
            return Math.abs(c1.r - c2.r) <= tol && 
                   Math.abs(c1.g - c2.g) <= tol && 
                   Math.abs(c1.b - c2.b) <= tol;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function drawSelection(start, end) {
            if (!start || !end) return;
            
            const x = Math.min(start.x, end.x);
            const y = Math.min(start.y, end.y);
            const width = Math.abs(end.x - start.x);
            const height = Math.abs(end.y - start.y);

            ctx.save();
            ctx.strokeStyle = '#14FFEC';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(x, y, width, height);
            ctx.restore();
        }

        // ============ SISTEMA DE SELECCI√ìN MEJORADO ============

        function selectAll() {
            activeSelection = {
                x: 0,
                y: 0,
                width: canvas.width,
                height: canvas.height
            };
            
            // Capturar imagen de la selecci√≥n
            captureSelection();
            
            selectionStart = {x: 0, y: 0};
            selectionEnd = {x: canvas.width, y: canvas.height};
            
            redrawCanvasWithShapes();
            drawActiveSelection();
            showNotification('Todo seleccionado (Ctrl+C para copiar, Supr para eliminar)', 'success');
        }

        function invertSelection() {
            if (!activeSelection) {
                showNotification('No hay selecci√≥n activa', 'warning');
                return;
            }
            
            // Por ahora, simplemente notificamos que la inversi√≥n est√° activa
            // Una implementaci√≥n completa requerir√≠a un sistema de regiones complejas
            showNotification('Inversi√≥n de selecci√≥n activada', 'info');
            
            // Implementaci√≥n b√°sica: seleccionar todo excepto la regi√≥n actual
            // Esto es m√°s complejo y requiere un canvas de m√°scara
        }

        function deleteSelection() {
            if (!activeSelection) {
                showNotification('No hay selecci√≥n activa', 'warning');
                return;
            }
            
            saveShapesState(); // Guardar para undo
            
            // Borrar el √°rea seleccionada del canvas
            const bgColor = backgroundState && backgroundState.color ? backgroundState.color : '#ffffff';
            
            if (backgroundState && backgroundState.type === 'transparent') {
                ctx.clearRect(activeSelection.x, activeSelection.y, activeSelection.width, activeSelection.height);
            } else {
                ctx.fillStyle = bgColor;
                ctx.fillRect(activeSelection.x, activeSelection.y, activeSelection.width, activeSelection.height);
            }
            
            // Convertir el canvas a una imagen y agregarlo a la capa
            const img = new Image();
            img.onload = function() {
                shapes.push({
                    type: 'image',
                    x: 0,
                    y: 0,
                    width: canvas.width,
                    height: canvas.height,
                    image: img,
                    imageData: canvas.toDataURL('image/png'),
                    selected: false
                });
                
                clearSelection();
                redrawCanvasWithShapes();
                showNotification('Selecci√≥n eliminada', 'success');
            };
            img.src = canvas.toDataURL();
        }

        function clearSelection() {
            activeSelection = null;
            selectionStart = null;
            selectionEnd = null;
            selectionImageData = null;
            freeformPoints = [];
            isMovingSelection = false;
            redrawCanvasWithShapes();
        }

        function toggleTransparentSelection() {
            transparentSelection = !transparentSelection;
            const indicator = document.getElementById('transparentSelectionIndicator');
            if (indicator) {
                indicator.textContent = transparentSelection ? '‚òë' : '‚òê';
            }
            showNotification(`Selecci√≥n transparente ${transparentSelection ? 'activada' : 'desactivada'}`, 'info');
        }

        function captureSelection() {
            if (!activeSelection) return;
            
            // Guardar posici√≥n original
            selectionOriginalX = activeSelection.x;
            selectionOriginalY = activeSelection.y;
            selectionMoved = false;
            
            // Guardar el canvas completo antes de hacer cambios
            canvasBeforeSelection = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Capturar los datos de imagen de la selecci√≥n
            selectionImageData = ctx.getImageData(
                activeSelection.x, 
                activeSelection.y, 
                activeSelection.width, 
                activeSelection.height
            );
        }

        function isPointInSelection(x, y) {
            if (!activeSelection) return false;
            return x >= activeSelection.x && 
                   x <= activeSelection.x + activeSelection.width &&
                   y >= activeSelection.y && 
                   y <= activeSelection.y + activeSelection.height;
        }

        // Dibuja la selecci√≥n flotante (solo imagen, sin marco) durante el movimiento
        function drawFloatingSelection() {
            if (!activeSelection || !selectionImageData) return;
            
            ctx.save();
            
            // Dibujar solo la imagen flotante
            ctx.putImageData(selectionImageData, activeSelection.x, activeSelection.y);
            
            // Dibujar borde simple (no animado) durante el movimiento
            ctx.strokeStyle = '#14FFEC';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
                activeSelection.x, 
                activeSelection.y, 
                activeSelection.width, 
                activeSelection.height
            );
            
            ctx.restore();
        }

        // Dibuja la selecci√≥n activa con marco animado (cuando NO se est√° moviendo)
        function drawActiveSelection() {
            if (!activeSelection) return;
            
            ctx.save();
            
            // Dibujar borde animado solo si NO se est√° moviendo
            ctx.strokeStyle = '#14FFEC';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            
            // Animar el borde de selecci√≥n
            const dashOffset = (Date.now() / 50) % 12;
            ctx.lineDashOffset = -dashOffset;
            
            ctx.strokeRect(
                activeSelection.x, 
                activeSelection.y, 
                activeSelection.width, 
                activeSelection.height
            );
            
            // Dibujar manijas de esquina
            const handleSize = 6;
            ctx.fillStyle = '#14FFEC';
            ctx.setLineDash([]);
            
            const corners = [
                {x: activeSelection.x, y: activeSelection.y}, // Superior izquierda
                {x: activeSelection.x + activeSelection.width, y: activeSelection.y}, // Superior derecha
                {x: activeSelection.x, y: activeSelection.y + activeSelection.height}, // Inferior izquierda
                {x: activeSelection.x + activeSelection.width, y: activeSelection.y + activeSelection.height} // Inferior derecha
            ];
            
            corners.forEach(corner => {
                ctx.fillRect(corner.x - handleSize/2, corner.y - handleSize/2, handleSize, handleSize);
            });
            
            ctx.restore();
        }

        function drawFreeformSelection() {
            if (freeformPoints.length < 2) return;
            
            ctx.save();
            ctx.strokeStyle = '#14FFEC';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            ctx.moveTo(freeformPoints[0].x, freeformPoints[0].y);
            
            for (let i = 1; i < freeformPoints.length; i++) {
                ctx.lineTo(freeformPoints[i].x, freeformPoints[i].y);
            }
            
            // Cerrar el path si hay suficientes puntos
            if (freeformPoints.length > 2) {
                ctx.closePath();
            }
            
            ctx.stroke();
            ctx.restore();
        }

        function finalizeFreeformSelection() {
            if (freeformPoints.length < 3) {
                showNotification('Dibuja un √°rea m√°s grande', 'warning');
                freeformPoints = [];
                return;
            }
            
            // Calcular bounding box
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            freeformPoints.forEach(point => {
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            });
            
            activeSelection = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
                freeform: true,
                points: [...freeformPoints]
            };
            
            captureSelection();
            redrawCanvasWithShapes();
            drawActiveSelection();
            
            showNotification('Selecci√≥n de forma libre creada', 'success');
            freeformPoints = [];
        }

        function finishShape() {
            // Funci√≥n para finalizar formas complejas como pol√≠gonos
            if (currentTool === 'polygon' && polygonModeActive && polygonPoints.length > 2) {
                // Guardar la forma
                shapes.push({
                    type: 'polygon',
                    points: [...polygonPoints],
                    color: currentColor,
                    lineWidth: brushSize,
                    selected: false,
                    rotation: 0
                });
                polygonPoints = [];
                polygonModeActive = false;
                redrawCanvasWithShapes();
                saveState();
            }
        }

        function handleCanvasDoubleClick(e) {
            if (currentTool === 'polygon' && polygonModeActive && polygonPoints.length > 2) {
                finishShape();
            }
        }

        // Funciones para selecci√≥n y manipulaci√≥n de figuras
        function getDistanceToShape(x, y, shape) {
            switch (shape.type) {
                case 'rectangle':
                    const rectCenterX = (shape.startX + shape.endX) / 2;
                    const rectCenterY = (shape.startY + shape.endY) / 2;
                    const rectWidth = Math.abs(shape.endX - shape.startX);
                    const rectHeight = Math.abs(shape.endY - shape.startY);
                    
                    const rectDx = Math.max(0, Math.abs(x - rectCenterX) - rectWidth / 2);
                    const rectDy = Math.max(0, Math.abs(y - rectCenterY) - rectHeight / 2);
                    return Math.sqrt(rectDx * rectDx + rectDy * rectDy);
                
                case 'circle':
                    // Para c√≠rculos, usar el radio calculado desde el centro
                    const circleCenterX = (shape.startX + shape.endX) / 2;
                    const circleCenterY = (shape.startY + shape.endY) / 2;
                    const circleRadius = Math.min(Math.abs(shape.endX - shape.startX), Math.abs(shape.endY - shape.startY)) / 2;
                    const circleCenterDistance = Math.sqrt(Math.pow(x - circleCenterX, 2) + Math.pow(y - circleCenterY, 2));
                    return Math.abs(circleCenterDistance - circleRadius);
                
                case 'ellipse':
                    // Para elipses, aproximaci√≥n usando distancia al centro ponderada
                    const ellipseCenterX = (shape.startX + shape.endX) / 2;
                    const ellipseCenterY = (shape.startY + shape.endY) / 2;
                    const radiusX = Math.abs((shape.endX - shape.startX) / 2);
                    const radiusY = Math.abs((shape.endY - shape.startY) / 2);
                    if (radiusX === 0 || radiusY === 0) return Infinity;
                    const ellipseVal = Math.sqrt(Math.pow((x - ellipseCenterX) / radiusX, 2) + Math.pow((y - ellipseCenterY) / radiusY, 2));
                    return Math.abs(ellipseVal - 1) * Math.min(radiusX, radiusY);
                
                case 'line':
                case 'arrow':
                    const lineDx = shape.endX - shape.startX;
                    const lineDy = shape.endY - shape.startY;
                    const length = Math.sqrt(lineDx * lineDx + lineDy * lineDy);
                    
                    if (length === 0) return Math.sqrt(Math.pow(x - shape.startX, 2) + Math.pow(y - shape.startY, 2));
                    
                    const t = Math.max(0, Math.min(1, ((x - shape.startX) * lineDx + (y - shape.startY) * lineDy) / (length * length)));
                    const projX = shape.startX + t * lineDx;
                    const projY = shape.startY + t * lineDy;
                    return Math.sqrt((x - projX) * (x - projX) + (y - projY) * (y - projY));
                
                case 'triangle':
                case 'star':
                    // Para tri√°ngulos y estrellas, usar distancia al centro como aproximaci√≥n
                    const triCenterX = (shape.startX + shape.endX) / 2;
                    const triCenterY = (shape.startY + shape.endY) / 2;
                    return Math.sqrt(Math.pow(x - triCenterX, 2) + Math.pow(y - triCenterY, 2));
                
                case 'brush':
                case 'pencil':
                    if (!shape.points || shape.points.length === 0) return Infinity;
                    
                    let minDistance = Infinity;
                    for (let i = 0; i < shape.points.length - 1; i++) {
                        const point1 = shape.points[i];
                        const point2 = shape.points[i + 1];
                        
                        const segmentDx = point2.x - point1.x;
                        const segmentDy = point2.y - point1.y;
                        const segmentLength = Math.sqrt(segmentDx * segmentDx + segmentDy * segmentDy);
                        
                        if (segmentLength === 0) continue;
                        
                        const segmentT = Math.max(0, Math.min(1, ((x - point1.x) * segmentDx + (y - point1.y) * segmentDy) / (segmentLength * segmentLength)));
                        const projX = point1.x + segmentT * segmentDx;
                        const projY = point1.y + segmentT * segmentDy;
                        const distance = Math.sqrt((x - projX) * (x - projX) + (y - projY) * (y - projY));
                        
                        minDistance = Math.min(minDistance, distance);
                    }
                    return minDistance;
            }
            return Infinity;
        }

        function isPointInShape(x, y, shape) {
            const tolerance = 12; // Reducido para mayor precisi√≥n
            return getDistanceToRotatedShape(x, y, shape) <= tolerance;
        }

        function getShapesUnderCursor(x, y) {
            // Ordenar por distancia (m√°s cercano primero)
            return shapes.filter(shape => isPointInShape(x, y, shape))
                         .sort((a, b) => getDistanceToRotatedShape(x, y, a) - getDistanceToRotatedShape(x, y, b));
        }

        function selectBestShapeAtPosition(x, y) {
            const shapesAtPosition = getShapesUnderCursor(x, y);
            
            if (shapesAtPosition.length === 0) return null;
            
            // Si hay figuras superpuestas, buscar la siguiente en la lista
            if (shapesAtPosition.length === 1) {
                lastClickedShapes = [shapesAtPosition[0]];
                return shapesAtPosition[0];
            }
            
            // Rotar entre las figuras en la misma posici√≥n
            let currentIndex = -1;
            if (lastClickedShapes.length > 0) {
                currentIndex = shapesAtPosition.indexOf(lastClickedShapes[lastClickedShapes.length - 1]);
            }
            
            const nextIndex = (currentIndex + 1) % shapesAtPosition.length;
            const selectedShape = shapesAtPosition[nextIndex];
            
            lastClickedShapes = [selectedShape];
            
            return selectedShape;
        }

        function moveShape(shape, deltaX, deltaY) {
            switch (shape.type) {
                case 'line':
                case 'arrow':
                case 'rectangle':
                case 'circle':
                case 'triangle':
                case 'star':
                case 'ellipse':
                    shape.startX += deltaX;
                    shape.startY += deltaY;
                    shape.endX += deltaX;
                    shape.endY += deltaY;
                    break;
                case 'brush':
                case 'pencil':
                    if (shape.points) {
                        shape.points.forEach(point => {
                            point.x += deltaX;
                            point.y += deltaY;
                        });
                        if (shape.centerX !== undefined) {
                            shape.centerX += deltaX;
                            shape.centerY += deltaY;
                        }
                    }
                    break;
                case 'text':
                    shape.x += deltaX;
                    shape.y += deltaY;
                    break;
            }
        }

        function resizeShape(shape, scaleFactor) {
            const centerX = shape.type === 'brush' && shape.centerX !== undefined ?
                shape.centerX :
                (shape.startX + shape.endX) / 2;
            const centerY = shape.type === 'brush' && shape.centerY !== undefined ?
                shape.centerY :
                (shape.startY + shape.endY) / 2;
            
            switch (shape.type) {
                case 'line':
                case 'arrow':
                case 'rectangle':
                case 'circle':
                case 'triangle':
                case 'star':
                case 'ellipse':
                    const halfWidth = (shape.endX - shape.startX) / 2;
                    const halfHeight = (shape.endY - shape.startY) / 2;
                    
                    shape.startX = centerX - halfWidth * scaleFactor;
                    shape.startY = centerY - halfHeight * scaleFactor;
                    shape.endX = centerX + halfWidth * scaleFactor;
                    shape.endY = centerY + halfHeight * scaleFactor;
                    break;
                case 'brush':
                case 'pencil':
                    if (shape.points) {
                        shape.points.forEach(point => {
                            const dx = point.x - centerX;
                            const dy = point.y - centerY;
                            point.x = centerX + dx * scaleFactor;
                            point.y = centerY + dy * scaleFactor;
                        });
                    }
                    break;
            }
        }

        function rotateShape(shape, angleChange) {
            // Acumular el √°ngulo de rotaci√≥n (mantener la geometr√≠a original)
            shape.rotation = (shape.rotation || 0) + angleChange;
            
            // Normalizar el √°ngulo entre -œÄ y œÄ
            while (shape.rotation > Math.PI) {
                shape.rotation -= 2 * Math.PI;
            }
            while (shape.rotation < -Math.PI) {
                shape.rotation += 2 * Math.PI;
            }
            
            // Actualizar la visualizaci√≥n del √°ngulo
            rotationAngle = shape.rotation * (180 / Math.PI); // Convertir a grados
            updateRotationDisplay();
            
            // NO modificar los puntos f√≠sicamente - la rotaci√≥n se aplica solo durante el renderizado
            // Esto permite que las figuras mantengan sus coordenadas originales para futuras manipulaciones
        }

        function calculateBrushCenter(points) {
            let sumX = 0, sumY = 0;
            points.forEach(point => {
                sumX += point.x;
                sumY += point.y;
            });
            return {
                x: sumX / points.length,
                y: sumY / points.length
            };
        }

        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function getAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        // Funci√≥n helper para rotar un punto alrededor de un centro
        function rotatePoint(x, y, centerX, centerY, angle) {
            const cos = Math.cos(-angle); // Negativo para rotaci√≥n inversa
            const sin = Math.sin(-angle);
            const dx = x - centerX;
            const dy = y - centerY;
            return {
                x: centerX + (dx * cos - dy * sin),
                y: centerY + (dx * sin + dy * cos)
            };
        }

        // Funci√≥n mejorada para detectar distancia considerando rotaci√≥n
        function getDistanceToRotatedShape(x, y, shape) {
            const rotation = shape.rotation || 0;
            
            // Si no hay rotaci√≥n, usar la funci√≥n normal
            if (Math.abs(rotation) < 0.001) {
                return getDistanceToShape(x, y, shape);
            }
            
            // Calcular el centro de rotaci√≥n
            let centerX, centerY;
            if (shape.type === 'brush' || shape.type === 'pencil') {
                centerX = shape.centerX || 0;
                centerY = shape.centerY || 0;
            } else if (shape.type === 'text') {
                centerX = shape.x;
                centerY = shape.y;
            } else {
                centerX = (shape.startX + shape.endX) / 2;
                centerY = (shape.startY + shape.endY) / 2;
            }
            
            // Rotar el punto de consulta en direcci√≥n opuesta
            const rotatedPoint = rotatePoint(x, y, centerX, centerY, rotation);
            
            // Usar la funci√≥n normal con el punto rotado
            return getDistanceToShape(rotatedPoint.x, rotatedPoint.y, shape);
        }

        function updateRotationDisplay() {
            const rotationInfo = document.getElementById('rotationInfo');
            const rotationSeparator = document.getElementById('rotationSeparator');
            const rotationAngleElement = document.getElementById('rotationAngle');
            
            if (isRotating && selectedShape) {
                rotationInfo.style.display = 'inline';
                rotationSeparator.style.display = 'inline';
                rotationAngleElement.textContent = Math.round(rotationAngle) + '¬∞';
            } else {
                rotationInfo.style.display = 'none';
                rotationSeparator.style.display = 'none';
            }
        }

        function hideRotationDisplay() {
            document.getElementById('rotationInfo').style.display = 'none';
            document.getElementById('rotationSeparator').style.display = 'none';
        }

        function drawShapeWithSelection(shape) {
            const originalStrokeStyle = ctx.strokeStyle;
            const originalLineWidth = ctx.lineWidth;
            const originalLineCap = ctx.lineCap;
            const originalFillStyle = ctx.fillStyle;
            
            // Configurar estilos
            const stroke = shape.color || shape.strokeColor || currentColor;
            const lineW = shape.lineWidth || brushSize;
            ctx.strokeStyle = shape.selected ? 'red' : stroke;
            ctx.lineWidth = shape.selected ? Math.max(3, lineW) : lineW;
            ctx.lineCap = 'round';
            ctx.fillStyle = shape.fillColor || currentColor;
            
            const rotation = shape.rotation || 0;
            const style = { fill: !!shape.fillEnabled };
            
            ctx.save();
            
            // Aplicar rotaci√≥n si existe
            if (rotation !== 0) {
                let centerX, centerY;
                
                // Calcular el centro seg√∫n el tipo de figura
                if (shape.type === 'brush' || shape.type === 'pencil') {
                    if (shape.centerX !== undefined && shape.centerY !== undefined) {
                        centerX = shape.centerX;
                        centerY = shape.centerY;
                    } else {
                        const center = calculateBrushCenter(shape.points || []);
                        centerX = center.x;
                        centerY = center.y;
                    }
                } else if (shape.type === 'text') {
                    centerX = shape.x;
                    centerY = shape.y;
                } else {
                    centerX = (shape.startX + shape.endX) / 2;
                    centerY = (shape.startY + shape.endY) / 2;
                }
                
                // Aplicar transformaci√≥n de rotaci√≥n
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation);
                ctx.translate(-centerX, -centerY);
            }
            
            // Dibujar la figura seg√∫n su tipo
            switch (shape.type) {
                case 'line':
                    drawLine(shape.startX, shape.startY, shape.endX, shape.endY);
                    break;
                case 'arrow':
                    drawArrow(shape.startX, shape.startY, shape.endX, shape.endY);
                    break;
                case 'rectangle':
                    drawRectangle(shape.startX, shape.startY, shape.endX, shape.endY, 0, style);
                    break;
                case 'circle':
                    drawCircle(shape.startX, shape.startY, shape.endX, shape.endY, 0, style);
                    break;
                case 'ellipse':
                    drawEllipse(shape.startX, shape.startY, shape.endX, shape.endY, 0, style);
                    break;
                case 'triangle':
                    drawTriangle(shape.startX, shape.startY, shape.endX, shape.endY, 0, style);
                    break;
                case 'star':
                    drawStar(shape.startX, shape.startY, shape.endX, shape.endY, 0, style);
                    break;
                case 'curve':
                    // Soporte para curvas cuadr√°ticas y c√∫bicas
                    ctx.beginPath();
                    ctx.moveTo(shape.startX, shape.startY);
                    if (shape.cp1x !== undefined && shape.cp1y !== undefined && shape.cp2x !== undefined && shape.cp2y !== undefined) {
                        // Curva c√∫bica
                        ctx.bezierCurveTo(shape.cp1x, shape.cp1y, shape.cp2x, shape.cp2y, shape.endX, shape.endY);
                    } else if (shape.controlX !== undefined && shape.controlY !== undefined) {
                        // Curva cuadr√°tica
                        ctx.quadraticCurveTo(shape.controlX, shape.controlY, shape.endX, shape.endY);
                    } else {
                        // Fallback: dibujar como l√≠nea si faltan controles
                        ctx.lineTo(shape.endX, shape.endY);
                    }
                    if (style.fill) ctx.fill();
                    ctx.stroke();
                    break;
                case 'brush':
                case 'pencil':
                    if (shape.points && shape.points.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(shape.points[0].x, shape.points[0].y);
                        for (let i = 1; i < shape.points.length; i++) {
                            ctx.lineTo(shape.points[i].x, shape.points[i].y);
                        }
                        ctx.stroke();
                    }
                    break;
                case 'polygon':
                    if (shape.points && shape.points.length > 0) {
                        ctx.beginPath();
                        ctx.moveTo(shape.points[0].x, shape.points[0].y);
                        for (let i = 1; i < shape.points.length; i++) {
                            ctx.lineTo(shape.points[i].x, shape.points[i].y);
                        }
                        ctx.closePath();
                        if (style.fill) ctx.fill();
                        ctx.stroke();
                    }
                    break;
                case 'text':
                    // Para texto, usar funci√≥n especializada si existe
                    if (typeof drawTextShape === 'function') {
                        drawTextShape(shape);
                    } else {
                        // Fallback simple para texto
                        const fontSize = shape.fontSize || 24;
                        const fontFamily = shape.fontFamily || 'Arial';
                        const bold = shape.bold ? 'bold ' : '';
                        const italic = shape.italic ? 'italic ' : '';
                        ctx.font = `${italic}${bold}${fontSize}px ${fontFamily}`;
                        ctx.fillStyle = shape.textColor || shape.color || currentColor;
                        ctx.textAlign = shape.align || 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText(shape.text || '', shape.x, shape.y);
                    }
                    break;
                case 'image':
                    if (shape.image && shape.image.complete) {
                        try {
                            ctx.drawImage(shape.image, shape.x, shape.y, shape.width, shape.height);
                            
                            // Dibujar borde si est√° seleccionada
                            if (shape.selected) {
                                ctx.save();
                                ctx.strokeStyle = 'red';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);
                                ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                                
                                // Dibujar manejadores de redimensionado
                                const handleSize = 8;
                                ctx.fillStyle = 'red';
                                ctx.setLineDash([]);
                                
                                // Esquinas
                                ctx.fillRect(shape.x - handleSize/2, shape.y - handleSize/2, handleSize, handleSize);
                                ctx.fillRect(shape.x + shape.width - handleSize/2, shape.y - handleSize/2, handleSize, handleSize);
                                ctx.fillRect(shape.x - handleSize/2, shape.y + shape.height - handleSize/2, handleSize, handleSize);
                                ctx.fillRect(shape.x + shape.width - handleSize/2, shape.y + shape.height - handleSize/2, handleSize, handleSize);
                                
                                ctx.restore();
                            }
                        } catch (err) {
                            console.error('Error dibujando imagen:', err);
                        }
                    }
                    break;
            }
            
            ctx.restore();
            
            // Restaurar estilos originales
            ctx.strokeStyle = originalStrokeStyle;
            ctx.lineWidth = originalLineWidth;
            ctx.lineCap = originalLineCap;
            ctx.fillStyle = originalFillStyle;
        }

        function saveShapesState() {
            // Guardar las figuras actuales en la capa activa
            if (layers[currentLayer]) {
                layers[currentLayer].shapes = [...shapes];
            }
            
            // Guardar estado completo de todas las capas
            shapesHistoryStep++;
            if (shapesHistoryStep < shapesHistory.length) {
                shapesHistory.length = shapesHistoryStep;
            }
            
            const layersState = {
                layers: JSON.parse(JSON.stringify(layers.map(layer => ({
                    id: layer.id,
                    name: layer.name,
                    visible: layer.visible,
                    opacity: layer.opacity,
                    shapes: layer.shapes
                })))),
                currentLayer: currentLayer,
                nextLayerId: nextLayerId,
                // Guardar tambi√©n el estado del fondo (color/gradiente)
                background: (function(){
                    try { return JSON.parse(JSON.stringify(backgroundState)); } catch(e) { return null; }
                })()
            };
            
            shapesHistory.push(JSON.stringify(layersState));
            
            // Limitar el historial
            if (shapesHistory.length > maxHistory) {
                shapesHistory.shift();
                shapesHistoryStep--;
            }
        }

        function restoreShapesState() {
            if (shapesHistoryStep >= 0 && shapesHistoryStep < shapesHistory.length) {
                const layersState = JSON.parse(shapesHistory[shapesHistoryStep]);
                
                // Restaurar capas
                layers = layersState.layers.map(layer => ({
                    ...layer,
                    canvas: document.createElement('canvas'),
                    ctx: null
                }));
                
                // Inicializar canvas para cada capa
                layers.forEach(layer => {
                    layer.canvas.width = canvas.width;
                    layer.canvas.height = canvas.height;
                    layer.ctx = layer.canvas.getContext('2d');
                });
                
                currentLayer = layersState.currentLayer;
                nextLayerId = layersState.nextLayerId;
                // Restaurar estado de fondo si est√° presente
                if (typeof layersState.background !== 'undefined' && layersState.background !== null) {
                    backgroundState = layersState.background;
                }
                shapes = [...layers[currentLayer].shapes];
                
                updateLayersList();
                redrawCanvasWithShapes();
            }
        }

        // Estado de fondo persistente (color/gradiente)
        // Usar var con comprobaci√≥n para evitar errores por redefinici√≥n si ya existe
        var backgroundState = (typeof backgroundState !== 'undefined') ? backgroundState : { type: 'color', color: '#ffffff' };

        function redrawCanvasWithShapes() {
            // Guardar las figuras actuales en la capa activa
            if (layers[currentLayer]) {
                layers[currentLayer].shapes = [...shapes];
            }
            
            // Limpiar el canvas completamente
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar fondo persistente (color, gradiente o transparente)
            try {
                if (backgroundState && backgroundState.type === 'transparent') {
                    // Fondo transparente - dibujar patr√≥n de cuadros para visualizar
                    drawTransparencyPattern();
                } else if (backgroundState && backgroundState.type === 'gradient') {
                    let g;
                    if (backgroundState.gradientType === 'linear') {
                        g = ctx.createLinearGradient(backgroundState.x1, backgroundState.y1, backgroundState.x2, backgroundState.y2);
                    } else if (backgroundState.gradientType === 'radial') {
                        const r = backgroundState.radius || Math.sqrt(Math.pow((backgroundState.x2 || 0) - (backgroundState.x1 || 0), 2) + Math.pow((backgroundState.y2 || 0) - (backgroundState.y1 || 0), 2));
                        g = ctx.createRadialGradient(backgroundState.x1, backgroundState.y1, 0, backgroundState.x1, backgroundState.y1, r);
                    } else if (backgroundState.gradientType === 'conic' && ctx.createConicGradient) {
                        g = ctx.createConicGradient(0, backgroundState.x1, backgroundState.y1);
                    }
                    if (g) {
                        g.addColorStop(0, backgroundState.color1 || '#000000');
                        g.addColorStop(1, backgroundState.color2 || '#ffffff');
                        ctx.fillStyle = g;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    } else {
                        // Fallback a blanco si no se pudo crear el gradiente
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                } else {
                    // Fondo de color s√≥lido
                    const bgColor = (backgroundState && backgroundState.color) ? backgroundState.color : '#ffffff';
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            } catch (e) {
                // En caso de error, usar blanco
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Dibujar cuadr√≠cula si est√° activada (directamente en el canvas)
            if (showGrid) {
                drawGridOnCanvas();
            }
            
            // Dibujar todas las capas en orden (de abajo hacia arriba)
            layers.forEach((layer, layerIndex) => {
                if (layer.visible && layer.shapes) {
                    // Configurar opacidad global para la capa
                    const originalGlobalAlpha = ctx.globalAlpha;
                    ctx.globalAlpha = layer.opacity;
                    
                    // Dibujar todas las figuras de esta capa
                    layer.shapes.forEach(shape => {
                        // Marcar si la forma est√° seleccionada solo si es de la capa activa
                        const shapeToRender = { 
                            ...shape, 
                            selected: layerIndex === currentLayer && shape.selected 
                        };
                        drawShapeWithSelection(shapeToRender);
                    });
                    
                    // Restaurar opacidad global
                    ctx.globalAlpha = originalGlobalAlpha;
                }
            });
        }

        // Funci√≥n para dibujar patr√≥n de transparencia (cuadros grises)
        function drawTransparencyPattern() {
            const squareSize = 10;
            const color1 = '#ffffff';
            const color2 = '#cccccc';
            
            for (let y = 0; y < canvas.height; y += squareSize) {
                for (let x = 0; x < canvas.width; x += squareSize) {
                    const isEven = (Math.floor(x / squareSize) + Math.floor(y / squareSize)) % 2 === 0;
                    ctx.fillStyle = isEven ? color1 : color2;
                    ctx.fillRect(x, y, squareSize, squareSize);
                }
            }
        }

        // Funci√≥n para establecer fondo transparente
        function setBackgroundTransparent() {
            backgroundState = { type: 'transparent' };
            saveShapesState();
            redrawCanvasWithShapes();
            showNotification('Fondo cambiado a transparente', 'success');
        }

        // Funci√≥n para establecer color de fondo
        function setBackgroundColor() {
            const color = prompt('Ingresa el color de fondo (hexadecimal):', backgroundState.color || '#ffffff');
            if (color && /^#[0-9A-F]{6}$/i.test(color)) {
                backgroundState = { type: 'color', color: color };
                saveShapesState();
                redrawCanvasWithShapes();
                showNotification(`Fondo cambiado a ${color}`, 'success');
            } else if (color) {
                showNotification('Color inv√°lido. Usa formato hexadecimal (#RRGGBB)', 'error');
            }
        }

        function drawGridOnCanvas() {
            if (!showGrid) return;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(20, 255, 236, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            
            // Dibujar l√≠neas verticales
            for (let x = gridSize; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Dibujar l√≠neas horizontales
            for (let y = gridSize; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function pickColor(pos, event) {
            const imageData = ctx.getImageData(pos.x, pos.y, 1, 1);
            const data = imageData.data;
            const hex = '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + data[2]).toString(16).slice(1);
            if (event && event.altKey) {
                // Alt: color secundario
                document.getElementById('colorPicker2').value = hex;
                updateColor2();
                showNotification('Color secundario capturado: ' + hex);
            } else {
                document.getElementById('colorPicker').value = hex;
                updateColor();
                showNotification('Color capturado: ' + hex);
            }
        }

        function setFillTolerance() {
            const value = prompt('Tolerancia de relleno (0-100):', fillTolerance);
            if (value !== null) {
                const n = parseInt(value, 10);
                if (!isNaN(n) && n >= 0 && n <= 100) {
                    fillTolerance = n;
                    showNotification(`Tolerancia de relleno: ${fillTolerance}`);
                } else {
                    showNotification('Valor inv√°lido para tolerancia de relleno', 'warning');
                }
            }
        }

        // ==========================================
        // FUNCIONES DE REDIMENSI√ìN DE CANVAS
        // ==========================================
        
        function showResizeDialog() {
            const modal = document.getElementById('resizeModal');
            const widthInput = document.getElementById('newWidth');
            const heightInput = document.getElementById('newHeight');
            const aspectCheckbox = document.getElementById('maintainAspect');
            
            // Establecer valores actuales
            widthInput.value = canvas.width;
            heightInput.value = canvas.height;
            
            // Event listeners para mantener proporci√≥n
            widthInput.oninput = function() {
                if (aspectCheckbox.checked) {
                    const ratio = canvas.height / canvas.width;
                    heightInput.value = Math.round(widthInput.value * ratio);
                }
            };
            
            heightInput.oninput = function() {
                if (aspectCheckbox.checked) {
                    const ratio = canvas.width / canvas.height;
                    widthInput.value = Math.round(heightInput.value * ratio);
                }
            };
            
            modal.style.display = 'flex';
        }
        
        function applyResize() {
            const newWidth = parseInt(document.getElementById('newWidth').value);
            const newHeight = parseInt(document.getElementById('newHeight').value);
            
            if (newWidth <= 0 || newHeight <= 0 || newWidth > 5000 || newHeight > 5000) {
                showNotification('Dimensiones inv√°lidas. Use valores entre 1 y 5000 p√≠xeles.', 'error');
                return;
            }
            
            // Guardar el contenido actual del canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0);
            
            // Redimensionar el canvas
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // Limpiar y establecer fondo blanco
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, newWidth, newHeight);
            
            // Redibujar el contenido anterior
            ctx.drawImage(tempCanvas, 0, 0);
            
            // Actualizar todas las capas con el nuevo tama√±o
            layers.forEach(layer => {
                if (layer.canvas) {
                    const layerTempCanvas = document.createElement('canvas');
                    const layerTempCtx = layerTempCanvas.getContext('2d');
                    layerTempCanvas.width = layer.canvas.width;
                    layerTempCanvas.height = layer.canvas.height;
                    layerTempCtx.drawImage(layer.canvas, 0, 0);
                    
                    layer.canvas.width = newWidth;
                    layer.canvas.height = newHeight;
                    layer.ctx.fillStyle = 'transparent';
                    layer.ctx.clearRect(0, 0, newWidth, newHeight);
                    layer.ctx.drawImage(layerTempCanvas, 0, 0);
                }
            });
            
            // Actualizar UI
            document.getElementById('canvasSize').textContent = `${newWidth} x ${newHeight} px`;
            updateRulers();
            updateFileSize();
            
            // Redibujar con las formas guardadas
            redrawCanvasWithShapes();
            
            closeResizeModal();
            showNotification(`Canvas redimensionado a ${newWidth} x ${newHeight} p√≠xeles`, 'success');
            
            // Guardar estado
            saveState();
            saveShapesState();
        }
        
        function closeResizeModal() {
            document.getElementById('resizeModal').style.display = 'none';
        }
        
        function resizeCanvasToPreset(width, height) {
            document.getElementById('newWidth').value = width;
            document.getElementById('newHeight').value = height;
            applyResize();
        }

        // ==========================================
        // FUNCIONES MEJORADAS DE CUADR√çCULA Y REGLAS
        // ==========================================
        
        function toggleGrid() {
            showGrid = !showGrid;
            const gridBtn = document.getElementById('gridBtn');
            
            if (showGrid) {
                if (gridBtn) {
                    gridBtn.classList.add('active');
                    gridBtn.style.backgroundColor = '#0d7377';
                    gridBtn.style.color = 'white';
                }
                showNotification('Cuadr√≠cula activada', 'success');
            } else {
                if (gridBtn) {
                    gridBtn.classList.remove('active');
                    gridBtn.style.backgroundColor = '';
                    gridBtn.style.color = '';
                }
                showNotification('Cuadr√≠cula desactivada', 'warning');
            }
            
            redrawCanvasWithShapes();
        }
        
        function setGridSize() {
            const newSize = prompt('Ingrese el tama√±o de la cuadr√≠cula (p√≠xeles):', gridSize);
            if (newSize !== null && !isNaN(newSize) && newSize > 0) {
                gridSize = parseInt(newSize);
                if (showGrid) {
                    redrawCanvasWithShapes();
                }
                showNotification(`Tama√±o de cuadr√≠cula: ${gridSize}px`, 'success');
            }
        }
        
        function toggleRulers() {
            showRulers = !showRulers;
            const rulerBtn = document.getElementById('rulersBtn');
            
            if (showRulers) {
                if (rulerBtn) {
                    rulerBtn.classList.add('active');
                    rulerBtn.style.backgroundColor = '#0d7377';
                    rulerBtn.style.color = 'white';
                }
                createRulers();
                showNotification('Reglas activadas', 'success');
            } else {
                if (rulerBtn) {
                    rulerBtn.classList.remove('active');
                    rulerBtn.style.backgroundColor = '';
                    rulerBtn.style.color = '';
                }
                hideRulers();
                showNotification('Reglas desactivadas', 'warning');
            }
        }
        
        function createRulers() {
            // Eliminar reglas existentes
            hideRulers();
            
            const canvasContainer = canvas.parentElement;
            
            // Crear regla horizontal
            const hRuler = document.createElement('div');
            hRuler.id = 'rulerHorizontal';
            hRuler.style.cssText = `
                position: absolute;
                top: 0;
                left: 20px;
                width: ${canvas.width}px;
                height: 20px;
                background: #f0f0f0;
                border-bottom: 1px solid #ccc;
                font-size: 10px;
                font-family: monospace;
                z-index: 100;
                overflow: hidden;
                pointer-events: none;
            `;
            
            // Agregar marcas a la regla horizontal
            for (let i = 0; i <= canvas.width; i += rulerUnit) {
                const mark = document.createElement('div');
                mark.style.cssText = `
                    position: absolute;
                    left: ${i}px;
                    top: 0;
                    width: 1px;
                    height: ${i % (rulerUnit * 10) === 0 ? '20px' : i % (rulerUnit * 5) === 0 ? '12px' : '8px'};
                    background: #666;
                `;
                hRuler.appendChild(mark);
                
                // Agregar n√∫meros cada 100 p√≠xeles
                if (i % (rulerUnit * 10) === 0 && i > 0) {
                    const label = document.createElement('div');
                    label.textContent = i.toString();
                    label.style.cssText = `
                        position: absolute;
                        left: ${i + 2}px;
                        top: 2px;
                        color: #333;
                        font-size: 9px;
                    `;
                    hRuler.appendChild(label);
                }
            }
            
            // Crear regla vertical
            const vRuler = document.createElement('div');
            vRuler.id = 'rulerVertical';
            vRuler.style.cssText = `
                position: absolute;
                top: 20px;
                left: 0;
                width: 20px;
                height: ${canvas.height}px;
                background: #f0f0f0;
                border-right: 1px solid #ccc;
                font-size: 10px;
                font-family: monospace;
                z-index: 100;
                overflow: hidden;
                pointer-events: none;
            `;
            
            // Agregar marcas a la regla vertical
            for (let i = 0; i <= canvas.height; i += rulerUnit) {
                const mark = document.createElement('div');
                mark.style.cssText = `
                    position: absolute;
                    top: ${i}px;
                    left: 0;
                    height: 1px;
                    width: ${i % (rulerUnit * 10) === 0 ? '20px' : i % (rulerUnit * 5) === 0 ? '12px' : '8px'};
                    background: #666;
                `;
                vRuler.appendChild(mark);
                
                // Agregar n√∫meros cada 100 p√≠xeles
                if (i % (rulerUnit * 10) === 0 && i > 0) {
                    const label = document.createElement('div');
                    label.textContent = i.toString();
                    label.style.cssText = `
                        position: absolute;
                        top: ${i + 2}px;
                        left: 2px;
                        color: #333;
                        font-size: 9px;
                        writing-mode: vertical-lr;
                        text-orientation: mixed;
                    `;
                    vRuler.appendChild(label);
                }
            }
            
            // Crear esquina de reglas
            const corner = document.createElement('div');
            corner.id = 'rulerCorner';
            corner.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 20px;
                height: 20px;
                background: #e0e0e0;
                border-right: 1px solid #ccc;
                border-bottom: 1px solid #ccc;
                z-index: 101;
                pointer-events: none;
            `;
            
            canvasContainer.appendChild(hRuler);
            canvasContainer.appendChild(vRuler);
            canvasContainer.appendChild(corner);
        }
        
        function hideRulers() {
            const hRuler = document.getElementById('rulerHorizontal');
            const vRuler = document.getElementById('rulerVertical');
            const corner = document.getElementById('rulerCorner');
            
            if (hRuler) hRuler.remove();
            if (vRuler) vRuler.remove();
            if (corner) corner.remove();
        }
        
        function updateRulers() {
            if (showRulers) {
                hideRulers();
                createRulers();
            }
        }
        
        function setRulerUnit() {
            const newUnit = prompt('Ingrese la unidad de las reglas (p√≠xeles por marca):', rulerUnit);
            if (newUnit !== null && !isNaN(newUnit) && newUnit > 0) {
                rulerUnit = parseInt(newUnit);
                if (showRulers) {
                    updateRulers();
                }
                showNotification(`Unidad de reglas: ${rulerUnit}px`, 'success');
            }
        }

        function openTextModal(shape) {
            editingTextShape = shape;
            const modal = document.getElementById('textModal');
            const input = document.getElementById('textInput');
            const fontSel = document.getElementById('fontFamily');
            const sizeInp = document.getElementById('fontSize');
            const bold = document.getElementById('boldText');
            const italic = document.getElementById('italicText');
            const alignSel = document.getElementById('textAlign');

            if (shape) {
                input.value = shape.text || '';
                fontSel.value = shape.fontFamily || 'Arial';
                sizeInp.value = shape.fontSize || 30;
                bold.checked = !!shape.bold;
                italic.checked = !!shape.italic;
                alignSel.value = shape.align || 'left';
                currentColor = shape.textColor || shape.color || currentColor;
                document.getElementById('colorPicker').value = currentColor;
            } else {
                input.value = '';
                fontSel.value = 'Arial';
                sizeInp.value = 30;
                bold.checked = false;
                italic.checked = false;
                alignSel.value = 'left';
            }
            modal.style.display = 'flex';
        }

        function addText() {
            const text = document.getElementById('textInput').value;
            const fontSize = parseInt(document.getElementById('fontSize').value, 10);
            const fontFamily = document.getElementById('fontFamily').value;
            const bold = document.getElementById('boldText').checked;
            const italic = document.getElementById('italicText').checked;
            const align = document.getElementById('textAlign').value;
            
            if (!text) { closeTextModal(); return; }
            
            saveShapesState();
            if (editingTextShape) {
                // Actualizar
                editingTextShape.text = text;
                editingTextShape.fontSize = fontSize;
                editingTextShape.fontFamily = fontFamily;
                editingTextShape.bold = bold;
                editingTextShape.italic = italic;
                editingTextShape.align = align;
                editingTextShape.textColor = currentColor;
            } else if (textPosition) {
                // Crear figura de texto
                shapes.push({
                    type: 'text',
                    x: textPosition.x,
                    y: textPosition.y,
                    text,
                    fontSize,
                    fontFamily,
                    bold,
                    italic,
                    align,
                    textColor: currentColor,
                    selected: false,
                    rotation: 0
                });
            }

            redrawCanvasWithShapes();
            saveState();
            closeTextModal();
        }

        function closeTextModal() {
            document.getElementById('textModal').style.display = 'none';
            document.getElementById('textInput').value = '';
            textPosition = null;
            editingTextShape = null;
        }

        // Filtros de imagen
        function applyFilter(filterType) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            showSpinner();
            
            setTimeout(() => {
                switch(filterType) {
                    case 'grayscale':
                        for (let i = 0; i < data.length; i += 4) {
                            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                            data[i] = data[i + 1] = data[i + 2] = avg;
                        }
                        break;
                        
                    case 'sepia':
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i], g = data[i + 1], b = data[i + 2];
                            data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                            data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                            data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
                        }
                        break;
                        
                    case 'invert':
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = 255 - data[i];
                            data[i + 1] = 255 - data[i + 1];
                            data[i + 2] = 255 - data[i + 2];
                        }
                        break;
                        
                    case 'brightness':
                        const brightness = 30;
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = Math.min(255, data[i] + brightness);
                            data[i + 1] = Math.min(255, data[i + 1] + brightness);
                            data[i + 2] = Math.min(255, data[i + 2] + brightness);
                        }
                        break;
                        
                    case 'contrast':
                        const factor = 1.5;
                        for (let i = 0; i < data.length; i += 4) {
                            data[i] = Math.min(255, (data[i] - 128) * factor + 128);
                            data[i + 1] = Math.min(255, (data[i + 1] - 128) * factor + 128);
                            data[i + 2] = Math.min(255, (data[i + 2] - 128) * factor + 128);
                        }
                        break;
                        
                    case 'blur':
                        applyConvolution(imageData, [
                            1/9, 1/9, 1/9,
                            1/9, 1/9, 1/9,
                            1/9, 1/9, 1/9
                        ]);
                        break;
                        
                    case 'sharpen':
                        applyConvolution(imageData, [
                            0, -1, 0,
                            -1, 5, -1,
                            0, -1, 0
                        ]);
                        break;
                        
                    case 'emboss':
                        applyConvolution(imageData, [
                            -2, -1, 0,
                            -1, 1, 1,
                            0, 1, 2
                        ]);
                        break;
                        
                    case 'edge':
                        applyConvolution(imageData, [
                            -1, -1, -1,
                            -1, 8, -1,
                            -1, -1, -1
                        ]);
                        break;
                        
                    case 'pixelate':
                        pixelateImage(imageData, 10);
                        break;
                        
                    case 'vintage':
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i], g = data[i + 1], b = data[i + 2];
                            data[i] = Math.min(255, r * 0.9 + 50);
                            data[i + 1] = Math.min(255, g * 0.8 + 30);
                            data[i + 2] = Math.min(255, b * 0.7);
                        }
                        break;
                }
                
                ctx.putImageData(imageData, 0, 0);
                saveState();
                hideSpinner();
                updateMinimap();
                showNotification('Filtro aplicado: ' + filterType);
            }, 100);
        }

        function applyConvolution(imageData, kernel) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const output = new Uint8ClampedArray(data);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let r = 0, g = 0, b = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4;
                            const k = kernel[(ky + 1) * 3 + (kx + 1)];
                            r += data[idx] * k;
                            g += data[idx + 1] * k;
                            b += data[idx + 2] * k;
                        }
                    }
                    
                    const outIdx = (y * width + x) * 4;
                    output[outIdx] = Math.min(255, Math.max(0, r));
                    output[outIdx + 1] = Math.min(255, Math.max(0, g));
                    output[outIdx + 2] = Math.min(255, Math.max(0, b));
                }
            }
            
            for (let i = 0; i < data.length; i++) {
                data[i] = output[i];
            }
        }

        function pixelateImage(imageData, blockSize) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            for (let y = 0; y < height; y += blockSize) {
                for (let x = 0; x < width; x += blockSize) {
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            r += data[idx];
                            g += data[idx + 1];
                            b += data[idx + 2];
                            count++;
                        }
                    }
                    
                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);
                    
                    for (let dy = 0; dy < blockSize && y + dy < height; dy++) {
                        for (let dx = 0; dx < blockSize && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                        }
                    }
                }
            }
        }

        // Transformaciones de imagen
        function rotateCanvas(angle) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            if (Math.abs(angle) === 90) {
                tempCanvas.width = canvas.height;
                tempCanvas.height = canvas.width;
            } else {
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
            }
            
            tempCtx.save();
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(angle * Math.PI / 180);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            tempCtx.restore();
            
            canvas.width = tempCanvas.width;
            canvas.height = tempCanvas.height;
            ctx.drawImage(tempCanvas, 0, 0);
            
            saveState();
            updateMinimap();
            showNotification('Canvas rotado ' + angle + '¬∞');
        }

        function flipHorizontal() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            tempCtx.save();
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(canvas, -canvas.width, 0);
            tempCtx.restore();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);
            
            saveState();
            updateMinimap();
            showNotification('Imagen volteada horizontalmente');
        }

        function flipVertical() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            tempCtx.save();
            tempCtx.scale(1, -1);
            tempCtx.drawImage(canvas, 0, -canvas.height);
            tempCtx.restore();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);
            
            saveState();
            updateMinimap();
            showNotification('Imagen volteada verticalmente');
        }

        function resizeCanvas() {
            document.getElementById('newWidth').value = canvas.width;
            document.getElementById('newHeight').value = canvas.height;
            document.getElementById('resizeModal').style.display = 'flex';
        }

        function applyResize() {
            const newWidth = parseInt(document.getElementById('newWidth').value);
            const newHeight = parseInt(document.getElementById('newHeight').value);
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0);
            
            canvas.width = newWidth;
            canvas.height = newHeight;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0, newWidth, newHeight);
            
            saveState();
            updateMinimap();
            updateCanvasSize();
            closeResizeModal();
            showNotification('Tama√±o cambiado a ' + newWidth + 'x' + newHeight);
        }

        function closeResizeModal() {
            document.getElementById('resizeModal').style.display = 'none';
        }

        // Zoom functions
        function zoomIn() {
            zoom = Math.min(zoom + 0.1, 5.0);
            applyZoom();
        }

        function zoomOut() {
            zoom = Math.max(zoom - 0.1, 0.1);
            applyZoom();
        }

        function resetZoom() {
            zoom = 1.0;
            applyZoom();
        }

        function applyZoom() {
            canvas.style.transform = `scale(${zoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            if (showRulers) {
                updateRulers();
            }
            if (showGrid) {
                updateGrid();
            }
        }

        // Funciones para reglas y cuadr√≠cula
        function toggleRulers() {
            showRulers = !showRulers;
            const rulersBtn = document.getElementById('rulersBtn');
            const rulerHorizontal = document.getElementById('rulerHorizontal');
            const rulerVertical = document.getElementById('rulerVertical');
            const rulerCorner = document.getElementById('rulerCorner');
            
            if (showRulers) {
                rulerHorizontal.style.display = 'block';
                rulerVertical.style.display = 'block';
                rulerCorner.style.display = 'block';
                rulersBtn.style.backgroundColor = '#4CAF50';
                updateRulers();
            } else {
                rulerHorizontal.style.display = 'none';
                rulerVertical.style.display = 'none';
                rulerCorner.style.display = 'none';
                rulersBtn.style.backgroundColor = '';
            }
        }

        function toggleGrid() {
            showGrid = !showGrid;
            const gridBtn = document.getElementById('gridBtn');
            
            if (showGrid) {
                if (gridBtn) {
                    gridBtn.classList.add('active');
                    gridBtn.style.backgroundColor = '#0d7377';
                    gridBtn.style.color = 'white';
                }
                showNotification('Cuadr√≠cula activada');
            } else {
                if (gridBtn) {
                    gridBtn.classList.remove('active');
                    gridBtn.style.backgroundColor = '';
                    gridBtn.style.color = '';
                }
                showNotification('Cuadr√≠cula desactivada');
            }
            
            // Redibujar el canvas con o sin cuadr√≠cula
            redrawCanvasWithShapes();
        }

        function updateRulers() {
            updateHorizontalRuler();
            updateVerticalRuler();
        }

        function updateHorizontalRuler() {
            const rulerHorizontal = document.getElementById('rulerHorizontal');
            const canvasWidth = canvas.width;
            rulerHorizontal.innerHTML = '';
            rulerHorizontal.style.width = (canvasWidth * zoom) + 'px';
            
            // Ajustar el espaciado seg√∫n el zoom
            let actualUnit = rulerUnit;
            if (zoom < 0.5) actualUnit = 50;
            else if (zoom < 1) actualUnit = 25;
            else if (zoom > 3) actualUnit = 5;
            
            const tickSpacing = actualUnit * zoom;
            const numberOfTicks = Math.ceil(canvasWidth / actualUnit);
            
            for (let i = 0; i <= numberOfTicks; i++) {
                const tick = document.createElement('div');
                tick.className = 'ruler-tick';
                tick.style.position = 'absolute';
                tick.style.left = (i * tickSpacing) + 'px';
                
                if (i % 5 === 0) {
                    tick.className += ' ruler-tick-major';
                    tick.textContent = (i * actualUnit).toString();
                } else {
                    tick.className += ' ruler-tick-minor';
                }
                
                rulerHorizontal.appendChild(tick);
            }
        }

        function updateVerticalRuler() {
            const rulerVertical = document.getElementById('rulerVertical');
            const canvasHeight = canvas.height;
            rulerVertical.innerHTML = '';
            rulerVertical.style.height = (canvasHeight * zoom) + 'px';
            
            // Ajustar el espaciado seg√∫n el zoom
            let actualUnit = rulerUnit;
            if (zoom < 0.5) actualUnit = 50;
            else if (zoom < 1) actualUnit = 25;
            else if (zoom > 3) actualUnit = 5;
            
            const tickSpacing = actualUnit * zoom;
            const numberOfTicks = Math.ceil(canvasHeight / actualUnit);
            
            for (let i = 0; i <= numberOfTicks; i++) {
                const tick = document.createElement('div');
                tick.className = 'ruler-tick';
                tick.style.position = 'absolute';
                tick.style.top = (i * tickSpacing) + 'px';
                
                if (i % 5 === 0) {
                    tick.className += ' ruler-tick-major';
                    tick.textContent = (i * actualUnit).toString();
                } else {
                    tick.className += ' ruler-tick-minor';
                }
                
                rulerVertical.appendChild(tick);
            }
        }

        function updateGrid() {
            if (!showGrid) return;
            
            const gridOverlay = document.getElementById('gridOverlay');
            if (!gridOverlay) {
                console.warn('Grid overlay element not found');
                return;
            }
            
            // Posicionar el overlay exactamente sobre el canvas
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            gridOverlay.style.width = canvasWidth + 'px';
            gridOverlay.style.height = canvasHeight + 'px';
            gridOverlay.style.left = '0px';
            gridOverlay.style.top = '0px';
            
            // Usar un patr√≥n de cuadr√≠cula m√°s visible con l√≠neas m√°s gruesas
            const actualGridSize = gridSize;
            gridOverlay.style.backgroundImage = `
                linear-gradient(to right, #14FFEC 1px, transparent 1px),
                linear-gradient(to bottom, #14FFEC 1px, transparent 1px)
            `;
            gridOverlay.style.backgroundSize = `${actualGridSize}px ${actualGridSize}px`;
            gridOverlay.style.backgroundPosition = '0 0';
            gridOverlay.style.opacity = '0.3';
            
            console.log('Grid updated:', { 
                width: canvasWidth, 
                height: canvasHeight, 
                gridSize: actualGridSize,
                display: gridOverlay.style.display 
            });
        }

        function handleWheel(e) {
            if (e.ctrlKey) {
                e.preventDefault();
                const area = document.getElementById('canvasArea');
                const rect = canvas.getBoundingClientRect();
                const areaRect = area.getBoundingClientRect();
                const offsetX = e.clientX - rect.left;
                const offsetY = e.clientY - rect.top;
                const normX = offsetX / zoom;
                const normY = offsetY / zoom;
                const oldZoom = zoom;

                if (e.deltaY < 0) zoomIn(); else zoomOut();

                // Mantener el punto bajo el cursor tras el zoom
                const newOffsetX = normX * zoom;
                const newOffsetY = normY * zoom;
                const targetScrollLeft = newOffsetX - (e.clientX - areaRect.left);
                const targetScrollTop = newOffsetY - (e.clientY - areaRect.top);
                area.scrollLeft = Math.max(0, targetScrollLeft);
                area.scrollTop = Math.max(0, targetScrollTop);
            } else if (rightClickHeld) {
                e.preventDefault();
                
                const pos = getMousePos(e);
                
                if (!isResizing) {
                    // Seleccionar figura para redimensionar
                    const shapeToResize = selectBestShapeAtPosition(pos.x, pos.y);
                    
                    if (shapeToResize) {
                        shapes.forEach(shape => shape.selected = false);
                        selectedShape = shapeToResize;
                        selectedShape.selected = true;
                        isResizing = true;
                        canvas.style.cursor = 'nesw-resize';
                        redrawCanvasWithShapes();
                        showNotification('Figura seleccionada para escalar (mant√©n click derecho + rueda)');
                    }
                }
                
                if (selectedShape && isResizing) {
                    const scaleFactor = e.deltaY > 0 ? 0.95 : 1.05; // Escalar hacia abajo o arriba
                    resizeShape(selectedShape, scaleFactor);
                    redrawCanvasWithShapes();
                }
            }
        }

        // Tool selection (keeping selectTool for backward compatibility)
        function selectTool(tool) {
            setTool(tool);
            
            if (tool === 'gradient') {
                updateFillStyle();
            }
        }

        // Color management
        function updateColor() {
            currentColor = document.getElementById('colorPicker').value;
            updateBrushPreview();
            updateGradientPreview();
        }

        function updateColor2() {
            currentColor2 = document.getElementById('colorPicker2').value;
            updateGradientPreview();
        }

        function swapColors() {
            const temp = currentColor;
            currentColor = currentColor2;
            currentColor2 = temp;
            document.getElementById('colorPicker').value = currentColor;
            document.getElementById('colorPicker2').value = currentColor2;
            updateBrushPreview();
            updateGradientPreview();
        }

        function updateColorPalette() {
            const palette = document.getElementById('colorPalette');
            palette.innerHTML = '';
            
            defaultPalette.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.onclick = () => {
                    document.getElementById('colorPicker').value = color;
                    updateColor();
                };
                palette.appendChild(swatch);
            });
        }

        function addCustomColor() {
            const color = document.getElementById('colorPicker').value;
            if (!defaultPalette.includes(color)) {
                defaultPalette.push(color);
                updateColorPalette();
                showNotification('Color agregado a la paleta');
            }
        }

        // Brush settings
        function updateBrushSize() {
            brushSize = parseInt(document.getElementById('brushSize').value);
            document.getElementById('brushSizeSlider').value = brushSize;
            updateBrushPreview();
        }

        function updateBrushSizeFromSlider() {
            brushSize = parseInt(document.getElementById('brushSizeSlider').value);
            document.getElementById('brushSize').value = brushSize;
            updateBrushPreview();
        }

        function updateOpacity() {
            const value = document.getElementById('opacitySlider').value;
            opacity = value / 100;
            document.getElementById('opacityValue').textContent = value + '%';
        }

        function updateBrushType() {
            brushType = document.getElementById('brushType').value;
            updateBrushPreview();
        }

        function updateSmoothing() {
            smoothing = document.getElementById('smoothingSlider').value;
        }

        function updateSpacing() {
            spacing = document.getElementById('spacingSlider').value;
        }

        function updateSymmetry() {
            symmetryMode = document.getElementById('symmetryMode').value;
        }

        function updateBrushPreview() {
            const preview = document.getElementById('brushCursor');
            preview.style.width = Math.min(brushSize * 2, 40) + 'px';
            preview.style.height = Math.min(brushSize * 2, 40) + 'px';
            preview.style.backgroundColor = currentColor;
            
            if (brushType === 'round') {
                preview.style.borderRadius = '50%';
            } else {
                preview.style.borderRadius = '0';
            }
        }

        function updateGradientType() {
            gradientType = document.getElementById('gradientType').value;
            updateGradientPreview();
        }

        function updateGradientPreview() {
            const preview = document.getElementById('gradientPreview');
            let gradient;
            
            if (gradientType === 'linear') {
                gradient = `linear-gradient(to right, ${currentColor}, ${currentColor2})`;
            } else if (gradientType === 'radial') {
                gradient = `radial-gradient(circle, ${currentColor}, ${currentColor2})`;
            } else if (gradientType === 'conic') {
                gradient = `conic-gradient(${currentColor}, ${currentColor2})`;
            }
            
            preview.style.background = gradient;
        }

        function updateFillStyle() {
            fillStyle = document.getElementById('fillStyle') ? document.getElementById('fillStyle').value : 'none';
        }

        // History management
        function saveState() {
            historyStep++;
            if (historyStep < history.length) {
                history.length = historyStep;
            }
            history.push(canvas.toDataURL());
            
            if (history.length > maxHistory) {
                history.shift();
                historyStep--;
            }
        }

        function restoreState() {
            if (historyStep >= 0 && history[historyStep]) {
                const img = new Image();
                img.src = history[historyStep];
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
            }
        }

        function undo() {
            if (shapesHistoryStep > 0) {
                shapesHistoryStep--;
                restoreShapesState();
                updateMinimap();
                showNotification('Deshacer');
            }
        }

        function redo() {
            if (shapesHistoryStep < shapesHistory.length - 1) {
                shapesHistoryStep++;
                restoreShapesState();
                updateMinimap();
                showNotification('Rehacer');
            }
        }

        // Tool management functions
        function setTool(tool) {
            currentTool = tool;
            
            // Remover clase active de todos los botones
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Agregar clase active al bot√≥n de la herramienta actual
            const toolBtn = document.getElementById(tool + 'Tool') || 
                           document.querySelector(`[onclick="setTool('${tool}')"]`) ||
                           document.querySelector(`[onclick*="${tool}"]`);
            
            if (toolBtn) {
                toolBtn.classList.add('active');
            }
            
            // Actualizar cursor del canvas seg√∫n la herramienta
            switch(tool) {
                case 'eyedropper':
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'eraser':
                    canvas.style.cursor = 'crosshair';
                    break;
                case 'text':
                    canvas.style.cursor = 'text';
                    break;
                case 'fill':
                    canvas.style.cursor = 'crosshair';
                    break;
                default:
                    canvas.style.cursor = 'crosshair';
            }
            
            showNotification(`Herramienta ${tool} seleccionada`);
        }

        // Sistema completo de capas
        function initializeLayers() {
            // Inicializar la primera capa con un canvas virtual
            layers[0].canvas = document.createElement('canvas');
            layers[0].canvas.width = canvas.width;
            layers[0].canvas.height = canvas.height;
            layers[0].ctx = layers[0].canvas.getContext('2d');
            layers[0].shapes = [];
        }

        function selectLayer(index) {
            if (index >= 0 && index < layers.length) {
                // Guardar las figuras actuales en la capa actual
                if (layers[currentLayer]) {
                    layers[currentLayer].shapes = [...shapes];
                }
                
                currentLayer = index;
                
                // Cargar las figuras de la nueva capa seleccionada
                shapes = [...layers[currentLayer].shapes];
                
                updateLayersList();
                redrawCanvasWithShapes();
                showNotification(`${layers[index].name} seleccionada`);
            }
        }

        function addLayer() {
            // Guardar las figuras actuales en la capa actual antes de crear nueva
            if (layers[currentLayer]) {
                layers[currentLayer].shapes = [...shapes];
            }
            
            const newLayer = {
                id: nextLayerId++,
                name: `Capa ${nextLayerId - 1}`,
                visible: true,
                opacity: 1.0,
                shapes: [],
                canvas: document.createElement('canvas'),
                ctx: null
            };
            
            newLayer.canvas.width = canvas.width;
            newLayer.canvas.height = canvas.height;
            newLayer.ctx = newLayer.canvas.getContext('2d');
            
            layers.push(newLayer);
            currentLayer = layers.length - 1;
            shapes = []; // Nueva capa empieza vac√≠a
            
            updateLayersList();
            redrawCanvasWithShapes();
            showNotification(`${newLayer.name} creada y seleccionada`);
        }

        function deleteLayer(index) {
            if (layers.length > 1 && index >= 0 && index < layers.length) {
                const deletedLayerName = layers[index].name;
                layers.splice(index, 1);
                
                // Ajustar currentLayer si es necesario
                if (currentLayer >= layers.length) {
                    currentLayer = layers.length - 1;
                } else if (currentLayer > index) {
                    currentLayer--;
                }
                
                // Cargar las figuras de la capa activa
                shapes = [...layers[currentLayer].shapes];
                
                updateLayersList();
                redrawCanvasWithShapes();
                showNotification(`${deletedLayerName} eliminada`);
            } else {
                showNotification('No se puede eliminar la √∫nica capa');
            }
        }

        function toggleLayerVisibility(index) {
            if (index >= 0 && index < layers.length) {
                layers[index].visible = !layers[index].visible;
                updateLayersList();
                redrawCanvasWithShapes();
                const status = layers[index].visible ? 'visible' : 'oculta';
                showNotification(`${layers[index].name} ${status}`);
            }
        }

        function changeLayerOpacity(index, opacity) {
            if (index >= 0 && index < layers.length) {
                layers[index].opacity = Math.max(0, Math.min(1, opacity));
                updateLayersList();
                redrawCanvasWithShapes();
                showNotification(`Opacidad de ${layers[index].name}: ${Math.round(layers[index].opacity * 100)}%`);
            }
        }

        function renameLayer(index, newName) {
            if (index >= 0 && index < layers.length && newName.trim()) {
                layers[index].name = newName.trim();
                updateLayersList();
                showNotification(`Capa renombrada a: ${newName}`);
            }
        }

        function moveLayerUp(index) {
            if (index > 0 && index < layers.length) {
                // Intercambiar capas
                [layers[index], layers[index - 1]] = [layers[index - 1], layers[index]];
                
                // Ajustar currentLayer si es necesario
                if (currentLayer === index) {
                    currentLayer = index - 1;
                } else if (currentLayer === index - 1) {
                    currentLayer = index;
                }
                
                updateLayersList();
                redrawCanvasWithShapes();
                showNotification(`${layers[index - 1].name} movida hacia arriba`);
            }
        }

        function moveLayerDown(index) {
            if (index >= 0 && index < layers.length - 1) {
                // Intercambiar capas
                [layers[index], layers[index + 1]] = [layers[index + 1], layers[index]];
                
                // Ajustar currentLayer si es necesario
                if (currentLayer === index) {
                    currentLayer = index + 1;
                } else if (currentLayer === index + 1) {
                    currentLayer = index;
                }
                
                updateLayersList();
                redrawCanvasWithShapes();
                showNotification(`${layers[index + 1].name} movida hacia abajo`);
            }
        }

        function duplicateLayer(index) {
            if (index >= 0 && index < layers.length) {
                const originalLayer = layers[index];
                const duplicatedLayer = {
                    id: nextLayerId++,
                    name: `${originalLayer.name} copia`,
                    visible: originalLayer.visible,
                    opacity: originalLayer.opacity,
                    shapes: [...originalLayer.shapes], // Copia profunda de las figuras
                    canvas: document.createElement('canvas'),
                    ctx: null
                };
                
                duplicatedLayer.canvas.width = canvas.width;
                duplicatedLayer.canvas.height = canvas.height;
                duplicatedLayer.ctx = duplicatedLayer.canvas.getContext('2d');
                
                // Insertar la copia despu√©s de la original
                layers.splice(index + 1, 0, duplicatedLayer);
                
                // Seleccionar la capa duplicada
                currentLayer = index + 1;
                shapes = [...duplicatedLayer.shapes];
                
                updateLayersList();
                redrawCanvasWithShapes();
                showNotification(`${duplicatedLayer.name} creada`);
            }
        }

        // Combinar capa actual con la inferior
        function mergeLayerDown(index = currentLayer) {
            if (index <= 0 || index >= layers.length) {
                showNotification('No se puede combinar: debe haber una capa inferior', 'error');
                return;
            }
            
            const upperLayer = layers[index];
            const lowerLayer = layers[index - 1];
            
            if (!upperLayer.visible && !lowerLayer.visible) {
                showNotification('Al menos una de las capas debe estar visible', 'error');
                return;
            }
            
            saveShapesState(); // Guardar para undo
            
            // Combinar las figuras de la capa superior en la inferior
            lowerLayer.shapes = [...lowerLayer.shapes, ...upperLayer.shapes];
            
            // Si la capa superior estaba visible y la inferior no, hacer visible la inferior
            if (upperLayer.visible && !lowerLayer.visible) {
                lowerLayer.visible = true;
            }
            
            // Conservar la mayor opacidad
            if (upperLayer.opacity > lowerLayer.opacity) {
                lowerLayer.opacity = upperLayer.opacity;
            }
            
            // Eliminar la capa superior
            layers.splice(index, 1);
            
            // Ajustar la capa actual
            if (currentLayer >= index) {
                currentLayer = Math.max(0, currentLayer - 1);
            }
            
            shapes = [...layers[currentLayer].shapes];
            
            showNotification(`Capa "${upperLayer.name}" combinada con "${lowerLayer.name}"`, 'success');
            updateLayersList();
            redrawCanvasWithShapes();
        }

        // Aplanar todas las capas en una sola
        function flattenLayers() {
            if (layers.length <= 1) {
                showNotification('Solo hay una capa, no hay nada que aplanar', 'info');
                return;
            }
            
            if (!confirm('¬øAplanar todas las capas? Esta acci√≥n combinar√° todas las capas visibles en una sola y no se puede deshacer completamente.')) {
                return;
            }
            
            saveShapesState(); // Guardar para undo
            
            // Crear una nueva capa que contendr√° todas las figuras
            const flattenedLayer = {
                id: nextLayerId++,
                name: 'Aplanado',
                visible: true,
                opacity: 1.0,
                shapes: [],
                canvas: document.createElement('canvas'),
                ctx: null
            };
            
            flattenedLayer.canvas.width = canvas.width;
            flattenedLayer.canvas.height = canvas.height;
            flattenedLayer.ctx = flattenedLayer.canvas.getContext('2d');
            
            // Combinar todas las figuras de todas las capas visibles
            for (let i = 0; i < layers.length; i++) {
                const layer = layers[i];
                if (layer.visible) {
                    // Aplicar la opacidad de la capa a cada figura si es menor a 1
                    if (layer.opacity < 1.0) {
                        // Crear copias de las figuras con opacidad ajustada
                        const adjustedShapes = layer.shapes.map(shape => {
                            const newShape = {...shape};
                            // Ajustar el color con la opacidad de la capa
                            if (newShape.color) {
                                const rgba = hexToRgba(newShape.color, layer.opacity);
                                newShape.color = rgba;
                            }
                            return newShape;
                        });
                        flattenedLayer.shapes.push(...adjustedShapes);
                    } else {
                        flattenedLayer.shapes.push(...layer.shapes);
                    }
                }
            }
            
            // Reemplazar todas las capas con la nueva capa aplanada
            layers = [flattenedLayer];
            currentLayer = 0;
            shapes = [...flattenedLayer.shapes];
            
            showNotification(`${flattenedLayer.shapes.length} figuras combinadas en una sola capa`, 'success');
            updateLayersList();
            redrawCanvasWithShapes();
        }

        // Funci√≥n auxiliar para convertir hex a rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function updateLayersList() {
            const layersList = document.getElementById('layersList');
            if (!layersList) return;

            layersList.innerHTML = '';
            
            // Mostrar capas en orden inverso (la m√°s alta primero)
            for (let i = layers.length - 1; i >= 0; i--) {
                const layer = layers[i];
                const layerDiv = document.createElement('div');
                layerDiv.className = `layer ${i === currentLayer ? 'active' : ''}`;
                layerDiv.onclick = () => selectLayer(i);
                
                // Hacer las capas arrastrables
                layerDiv.draggable = true;
                layerDiv.dataset.layerIndex = i;
                
                // Eventos de drag & drop
                layerDiv.ondragstart = handleLayerDragStart;
                layerDiv.ondragover = handleLayerDragOver;
                layerDiv.ondrop = handleLayerDrop;
                layerDiv.ondragend = handleLayerDragEnd;
                layerDiv.ondragenter = handleLayerDragEnter;
                layerDiv.ondragleave = handleLayerDragLeave;
                
                layerDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                        <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                            <span style="cursor: grab; color: #888;">‚ò∞</span>
                            <button onclick="event.stopPropagation(); toggleLayerVisibility(${i})" 
                                    style="background: none; border: none; color: ${layer.visible ? '#14FFEC' : '#666'}; font-size: 14px; cursor: pointer;">
                                ${layer.visible ? 'üëÅ' : 'üôà'}
                            </button>
                            <span style="flex: 1; font-size: 12px;" ondblclick="renameLayerPrompt(${i})">${layer.name}</span>
                            <span style="font-size: 10px; color: #888;">${Math.round(layer.opacity * 100)}%</span>
                        </div>
                        <div style="display: flex; gap: 2px;">
                            ${i > 0 ? `<button onclick="event.stopPropagation(); moveLayerUp(${i})" 
                                              style="background: none; border: none; color: #888; font-size: 10px; cursor: pointer;" title="Subir">‚ñ≤</button>` : ''}
                            ${i < layers.length - 1 ? `<button onclick="event.stopPropagation(); moveLayerDown(${i})" 
                                              style="background: none; border: none; color: #888; font-size: 10px; cursor: pointer;" title="Bajar">‚ñº</button>` : ''}
                            <button onclick="event.stopPropagation(); duplicateLayer(${i})" 
                                    style="background: none; border: none; color: #888; font-size: 10px; cursor: pointer;" title="Duplicar">üìã</button>
                            ${layers.length > 1 ? `<button onclick="event.stopPropagation(); deleteLayer(${i})" 
                                                          style="background: none; border: none; color: #ff6b6b; font-size: 10px; cursor: pointer;" title="Eliminar">üóë</button>` : ''}
                        </div>
                    </div>
                    <div style="margin-top: 5px;">
                        <input type="range" min="0" max="100" value="${Math.round(layer.opacity * 100)}" 
                               onchange="changeLayerOpacity(${i}, this.value / 100)" 
                               onclick="event.stopPropagation()"
                               style="width: 100%; height: 4px;">
                    </div>
                `;
                
                layersList.appendChild(layerDiv);
            }
        }

        // Variables globales para drag & drop de capas
        let draggedLayerIndex = null;
        let dragOverLayerIndex = null;

        function handleLayerDragStart(e) {
            draggedLayerIndex = parseInt(e.currentTarget.dataset.layerIndex);
            e.currentTarget.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.currentTarget.innerHTML);
        }

        function handleLayerDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleLayerDragEnter(e) {
            const targetIndex = parseInt(e.currentTarget.dataset.layerIndex);
            if (targetIndex !== draggedLayerIndex) {
                e.currentTarget.style.borderTop = '2px solid #14FFEC';
            }
        }

        function handleLayerDragLeave(e) {
            e.currentTarget.style.borderTop = '';
        }

        function handleLayerDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();
            
            const targetIndex = parseInt(e.currentTarget.dataset.layerIndex);
            
            if (draggedLayerIndex !== null && targetIndex !== draggedLayerIndex) {
                // Reordenar capas
                const draggedLayer = layers[draggedLayerIndex];
                
                // Remover la capa arrastrada
                layers.splice(draggedLayerIndex, 1);
                
                // Insertar en la nueva posici√≥n
                // Ajustar el √≠ndice si es necesario
                let newIndex = targetIndex;
                if (draggedLayerIndex < targetIndex) {
                    newIndex--;
                }
                layers.splice(newIndex, 0, draggedLayer);
                
                // Actualizar currentLayer si es necesario
                if (currentLayer === draggedLayerIndex) {
                    currentLayer = newIndex;
                } else if (draggedLayerIndex < currentLayer && newIndex >= currentLayer) {
                    currentLayer--;
                } else if (draggedLayerIndex > currentLayer && newIndex <= currentLayer) {
                    currentLayer++;
                }
                
                updateLayersList();
                redrawCanvasWithShapes();
                showNotification('Capa reordenada', 'success');
            }
            
            e.currentTarget.style.borderTop = '';
            return false;
        }

        function handleLayerDragEnd(e) {
            e.currentTarget.style.opacity = '1';
            draggedLayerIndex = null;
            
            // Limpiar bordes de todos los elementos
            const allLayers = document.querySelectorAll('.layer');
            allLayers.forEach(layer => {
                layer.style.borderTop = '';
            });
        }

        function renameLayerPrompt(index) {
            const currentName = layers[index].name;
            const newName = prompt('Nuevo nombre para la capa:', currentName);
            if (newName && newName !== currentName) {
                renameLayer(index, newName);
            }
        }

        // Canvas operations
        function newCanvas() {
            if (confirm('¬øCrear un nuevo canvas? Se perder√° el trabajo actual.')) {
                backgroundState = { type: 'color', color: '#ffffff' };
                redrawCanvasWithShapes();
                shapes = []; // Limpiar figuras guardadas
                shapesHistory = [];
                shapesHistoryStep = -1;
                saveShapesState(); // Guardar estado limpio
                lastClickedShapes = [];
                selectedShape = null;
                history = [];
                historyStep = -1;
                saveState();
                updateMinimap();
                showNotification('Nuevo canvas creado');
            }
        }

        function clearCanvas() {
            if (confirm('¬øEst√°s seguro de que quieres limpiar el canvas?')) {
                backgroundState = { type: 'color', color: '#ffffff' };
                redrawCanvasWithShapes();
                shapes = []; // Limpiar tambi√©n las figuras guardadas
                shapesHistory = [];
                shapesHistoryStep = -1;
                saveShapesState(); // Guardar estado limpio
                lastClickedShapes = [];
                selectedShape = null;
                saveState();
                updateMinimap();
                showNotification('Canvas limpiado');
            }
        }

        function saveImage() {
            // Exportar la composici√≥n final de todas las capas visibles
            // Si el fondo es transparente, crear un canvas temporal sin el patr√≥n de cuadros
            if (backgroundState && backgroundState.type === 'transparent') {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Dibujar todas las capas visibles sin fondo
                layers.forEach((layer, layerIndex) => {
                    if (layer.visible && layer.shapes) {
                        const originalGlobalAlpha = tempCtx.globalAlpha;
                        tempCtx.globalAlpha = layer.opacity;
                        
                        layer.shapes.forEach(shape => {
                            const savedCtx = ctx;
                            ctx = tempCtx;
                            drawShapeWithSelection({ ...shape, selected: false });
                            ctx = savedCtx;
                        });
                        
                        tempCtx.globalAlpha = originalGlobalAlpha;
                    }
                });
                
                const link = document.createElement('a');
                link.download = 'paint-pro-' + Date.now() + '.png';
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                showNotification('Imagen PNG exportada con transparencia', 'success');
            } else {
                // Exportar normalmente si tiene fondo
                const link = document.createElement('a');
                link.download = 'paint-pro-' + Date.now() + '.png';
                link.href = canvas.toDataURL();
                link.click();
                showNotification('Imagen exportada (todas las capas visibles combinadas)');
            }
        }

        function saveAsJPEG() {
            // Exportar la composici√≥n final como JPEG
            const link = document.createElement('a');
            link.download = 'paint-pro-' + Date.now() + '.jpg';
            link.href = canvas.toDataURL('image/jpeg', 0.9);
            link.click();
            showNotification('Imagen exportada como JPEG (todas las capas visibles combinadas)');
        }
        
        function exportCurrentLayerOnly() {
            // Exportar solo la capa activa como imagen
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Dibujar fondo blanco
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Dibujar solo las figuras de la capa actual
            const currentLayerShapes = layers[currentLayer].shapes || [];
            tempCtx.globalAlpha = layers[currentLayer].opacity;
            currentLayerShapes.forEach(shape => {
                drawShapeOnContext(tempCtx, shape);
            });
            
            const link = document.createElement('a');
            link.download = `${layers[currentLayer].name}-${Date.now()}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
            showNotification(`Capa "${layers[currentLayer].name}" exportada`);
        }
        
        function drawShapeOnContext(context, shape) {
            // Funci√≥n auxiliar para dibujar una figura en un contexto espec√≠fico
            const savedCtx = ctx;
            ctx = context;
            drawShapeWithSelection({ ...shape, selected: false });
            ctx = savedCtx;
        }

        function loadImage() {
            document.getElementById('fileInput').click();
        }

        function importImage() {
            loadImage();
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        if (img.width !== canvas.width || img.height !== canvas.height) {
                            if (confirm('¬øAjustar el tama√±o del canvas a la imagen?')) {
                                canvas.width = img.width;
                                canvas.height = img.height;
                                updateCanvasSize();
                            }
                        }
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                        saveState();
                        updateMinimap();
                        showNotification('Imagen cargada');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function copyCanvas() {
            clipboard = canvas.toDataURL();
            showNotification('Canvas copiado al portapapeles');
        }

        function pasteCanvas() {
            if (clipboard) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    saveState();
                    updateMinimap();
                    showNotification('Canvas pegado');
                };
                img.src = clipboard;
            }
        }

        // Utility functions
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            // Limitar a los bordes del canvas
            const clampedX = Math.max(0, Math.min(canvas.width - 1, x));
            const clampedY = Math.max(0, Math.min(canvas.height - 1, y));
            return { x: clampedX, y: clampedY };
        }

        function updateStatus() {
            const toolNames = {
                'brush': 'Pincel',
                'pencil': 'L√°piz',
                'spray': 'Aerosol',
                'eraser': 'Borrador',
                'line': 'L√≠nea',
                'rectangle': 'Rect√°ngulo',
                'circle': 'C√≠rculo',
                'triangle': 'Tri√°ngulo',
                'polygon': 'Pol√≠gono',
                'star': 'Estrella',
                'arrow': 'Flecha',
                'curve': 'Curva',
                'fill': 'Relleno',
                'text': 'Texto',
                'gradient': 'Gradiente',
                'eyedropper': 'Cuentagotas',
                'select': 'Seleccionar',
                'move': 'Mover',
                'clone': 'Clonar',
                'blur': 'Desenfocar'
            };
            document.getElementById('status').textContent = `Listo | Herramienta: ${toolNames[currentTool]}`;
        }

        function updateCoordinates(e) {
            const pos = getMousePos(e);
            document.getElementById('coordinates').textContent = `X: ${Math.floor(pos.x)}, Y: ${Math.floor(pos.y)}`;
        }

        function updateCanvasSize() {
            document.getElementById('canvasSize').textContent = `${canvas.width} x ${canvas.height} px`;
        }

        function updateFileSize() {
            const dataUrl = canvas.toDataURL();
            const size = Math.round((dataUrl.length * 3) / 4 / 1024);
            document.getElementById('fileSize').textContent = `Tama√±o: ${size} KB`;
        }

        function updateMinimap() {
            const scale = Math.min(minimapCanvas.width / canvas.width, minimapCanvas.height / canvas.height);
            const width = canvas.width * scale;
            const height = canvas.height * scale;
            
            minimapCtx.fillStyle = '#3e3e3e';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            minimapCtx.drawImage(canvas, 0, 0, width, height);
        }

        function showSpinner() {
            document.getElementById('spinner').style.display = 'block';
        }

        function hideSpinner() {
            document.getElementById('spinner').style.display = 'none';
        }

        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        function toggleGrid() {
            showGrid = !showGrid;
            showNotification(showGrid ? 'Cuadr√≠cula activada' : 'Cuadr√≠cula desactivada');
        }

        function toggleRulers() {
            showNotification('Funci√≥n de reglas en desarrollo');
        }

        function toggleMinimap() {
            const minimap = document.querySelector('.minimap').parentElement;
            minimap.style.display = minimap.style.display === 'none' ? 'block' : 'none';
        }

        function fullscreen() {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        }

        function showShortcuts() {
            alert(`Atajos de teclado:
            
Ctrl + N: Nuevo canvas
Ctrl + O: Abrir imagen
Ctrl + S: Exportar imagen
Ctrl + P: Guardar proyecto
Ctrl + R: Redimensionar canvas
Ctrl + Z: Deshacer
Ctrl + Y: Rehacer
Ctrl + C: Copiar canvas al portapapeles
Ctrl + V: Pegar imagen desde portapapeles
Ctrl + Rueda: Zoom

Teclas r√°pidas:
B: Pincel
P: L√°piz
E: Borrador
F: Relleno
I: Cuentagotas
L: L√≠nea
R: Rect√°ngulo
C: C√≠rculo
T: Tri√°ngulo
X: Texto
M: Seleccionar
V: Mover

Funciones adicionales:
‚Ä¢ Arrastra y suelta im√°genes al canvas
‚Ä¢ Copia im√°genes desde otras aplicaciones
‚Ä¢ M√∫ltiples capas con opacidad individual
‚Ä¢ Cuadr√≠cula y reglas configurables
‚Ä¢ Redimensi√≥n con presets comunes

Manipulaci√≥n de figuras:
Ctrl + Click: Mover figuras
Shift + Click: Rotar figuras
Click derecho + Rueda: Escalar figuras

Notas:
- Las figuras se resaltan en rojo cuando est√°n seleccionadas
- Si hay figuras superpuestas, haz clic varias veces para seleccionar diferentes figuras
- Mant√©n presionada la tecla modificadora mientras arrastras`);
        }

        function showAbout() {
            alert('Paint Pro v2.0\n\nEditor de im√°genes avanzado\nCreado con HTML5 Canvas\n\n¬© 2025');
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // No capturar atajos mientras se escribe en inputs/select/textarea o cuando el modal de texto est√° abierto
            const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : '';
            const isTyping = tag === 'input' || tag === 'textarea' || tag === 'select' || (document.activeElement && document.activeElement.isContentEditable);
            const tm0 = document.getElementById('textModal');
            const isTextModalOpen = tm0 && tm0.style.display === 'flex';
            if (isTyping || isTextModalOpen) {
                // Permitir cerrar con ESC aunque se est√© escribiendo
                if (e.key === 'Escape') {
                    const tm = document.getElementById('textModal');
                    if (tm && tm.style.display === 'flex') closeTextModal();
                }
                return;
            }

            // Finalizaci√≥n/cancelaci√≥n de interacci√≥n de POL√çGONO y CURVA
            if (e.key === 'Enter') {
                if (currentTool === 'polygon' && polygonModeActive) {
                    e.preventDefault();
                    finishShape();
                    return;
                }
                if (currentTool === 'freeformSelect' && freeformPoints.length > 0) {
                    e.preventDefault();
                    finalizeFreeformSelection();
                    return;
                }
            }
            if (e.key === 'Escape') {
                // Cancelar selecci√≥n activa
                if (activeSelection) {
                    e.preventDefault();
                    clearSelection();
                    showNotification('Selecci√≥n cancelada');
                    return;
                }
                if (currentTool === 'polygon' && polygonModeActive) {
                    e.preventDefault();
                    polygonPoints = [];
                    polygonModeActive = false;
                    redrawCanvasWithShapes();
                    showNotification('Pol√≠gono cancelado');
                    return;
                }
                if (currentTool === 'curve' && curvePhase > 0) {
                    e.preventDefault();
                    curvePhase = 0;
                    curveStart = null;
                    curveEnd = null;
                    curveCp1 = null;
                    curveCp2 = null;
                    isDrawing = false;
                    redrawCanvasWithShapes();
                    showNotification('Curva cancelada');
                    return;
                }
                if (currentTool === 'freeformSelect' && freeformPoints.length > 0) {
                    e.preventDefault();
                    freeformPoints = [];
                    redrawCanvasWithShapes();
                    showNotification('Selecci√≥n libre cancelada');
                    return;
                }
            }
            // Tecla Suprimir para eliminar selecci√≥n
            if (e.key === 'Delete' || e.key === 'Supr') {
                if (activeSelection) {
                    e.preventDefault();
                    deleteSelection();
                    return;
                }
            }
            if (e.ctrlKey) {
                switch(e.key.toLowerCase()) {
                    case 'a':
                        e.preventDefault();
                        selectAll();
                        break;
                    case 'n':
                        e.preventDefault();
                        newCanvas();
                        break;
                    case 'o':
                        e.preventDefault();
                        loadImage();
                        break;
                    case 's':
                        e.preventDefault();
                        saveImage();
                        break;
                    case 'z':
                        e.preventDefault();
                        undo();
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                    case 'c':
                        e.preventDefault();
                        copyCanvasToClipboard();
                        break;
                    case 'v':
                        e.preventDefault();
                        pasteFromClipboard();
                        break;
                    case 'p':
                        e.preventDefault();
                        saveProject();
                        break;
                    case 'r':
                        e.preventDefault();
                        showResizeDialog();
                        break;
                }
            } else {
                switch(e.key.toLowerCase()) {
                    case 'b':
                        setTool('brush');
                        break;
                    case 'p':
                        setTool('pencil');
                        break;
                    case 'e':
                        setTool('eraser');
                        break;
                    case 'f':
                        setTool('fill');
                        break;
                    case 'i':
                        setTool('eyedropper');
                        break;
                    case 'l':
                        selectTool('line');
                        break;
                    case 'r':
                        selectTool('rectangle');
                        break;
                    case 'c':
                        selectTool('circle');
                        break;
                    case 't':
                        setTool('triangle');
                        break;
                    case 'x':
                        setTool('text');
                        break;
                    case 'm':
                        if (e.shiftKey) {
                            setTool('freeformSelect');
                        } else {
                            setTool('select');
                        }
                        break;
                    case 'v':
                        setTool('move');
                        break;
                }
            }
            // Cerrar modal con ESC (si no se intercept√≥ antes)
            if (e.key === 'Escape') {
                const tm = document.getElementById('textModal');
                if (tm && tm.style.display === 'flex') closeTextModal();
            }
        });

        // ==========================================
        // FUNCIONES DE GUARDAR/CARGAR PROYECTO
        // ==========================================

        function saveProject() {
            try {
                // Preparar datos del proyecto
                const projectData = {
                    version: '2.0',
                    name: projectName,
                    timestamp: new Date().toISOString(),
                    canvas: {
                        width: canvas.width,
                        height: canvas.height,
                        backgroundColor: '#ffffff',
                        background: (function(){
                            try { return JSON.parse(JSON.stringify(backgroundState)); } catch(e) { return null; }
                        })()
                    },
                    layers: layers.map(layer => ({
                        id: layer.id,
                        name: layer.name,
                        visible: layer.visible,
                        opacity: layer.opacity,
                        shapes: layer.shapes.map(shape => {
                            // Serializar la forma, excluyendo objetos no serializables
                            const serializedShape = { ...shape };
                            
                            // Si es una imagen, convertir a base64
                            if (shape.type === 'image' && shape.image) {
                                try {
                                    const tempCanvas = document.createElement('canvas');
                                    const tempCtx = tempCanvas.getContext('2d');
                                    
                                    // Usar las dimensiones de la imagen o del shape
                                    const imgWidth = shape.width || shape.image.width || shape.image.naturalWidth || 100;
                                    const imgHeight = shape.height || shape.image.height || shape.image.naturalHeight || 100;
                                    
                                    tempCanvas.width = imgWidth;
                                    tempCanvas.height = imgHeight;
                                    
                                    // Verificar que la imagen sea v√°lida antes de dibujar
                                    if (shape.image.complete && shape.image.naturalWidth > 0) {
                                        tempCtx.drawImage(shape.image, 0, 0, imgWidth, imgHeight);
                                        serializedShape.imageData = tempCanvas.toDataURL();
                                    } else if (shape.imageData) {
                                        // Si ya tiene imageData guardado, usarlo
                                        serializedShape.imageData = shape.imageData;
                                    } else {
                                        console.warn('Imagen no v√°lida, se omitir√° en el guardado');
                                    }
                                    
                                    // Guardar dimensiones
                                    serializedShape.width = imgWidth;
                                    serializedShape.height = imgHeight;
                                    
                                    delete serializedShape.image; // Remover la referencia del objeto Image
                                } catch (error) {
                                    console.error('Error serializando imagen:', error);
                                    // Si hay error, intentar preservar imageData existente
                                    if (shape.imageData) {
                                        serializedShape.imageData = shape.imageData;
                                    }
                                    delete serializedShape.image;
                                }
                            }
                            
                            return serializedShape;
                        })
                    })),
                    currentLayer: currentLayer,
                    nextLayerId: nextLayerId,
                    settings: {
                        gridEnabled: showGrid,
                        gridSize: gridSize,
                        brushSize: brushSize,
                        currentColor: currentColor,
                        currentColor2: currentColor2,
                        fillStyle: fillStyle,
                        opacity: opacity
                    }
                };

                // Crear archivo y descargarlo
                const dataStr = JSON.stringify(projectData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `${projectName}.paintpro`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification(`Proyecto "${projectName}" guardado exitosamente`, 'success');
                
                // Actualizar t√≠tulo
                updateWindowTitle();
                
            } catch (err) {
                console.error('Error guardando proyecto:', err);
                showNotification('Error al guardar el proyecto', 'error');
            }
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.paintpro,.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const projectData = JSON.parse(event.target.result);
                        
                        if (!projectData.version || !projectData.layers) {
                            throw new Error('Formato de archivo no v√°lido');
                        }
                        
                        // Restaurar configuraci√≥n del canvas
                        if (projectData.canvas) {
                            canvas.width = projectData.canvas.width || 800;
                            canvas.height = projectData.canvas.height || 600;
                            // Restaurar fondo si existe
                            if (projectData.canvas.background) {
                                backgroundState = projectData.canvas.background;
                            } else if (projectData.canvas.backgroundColor) {
                                backgroundState = { type: 'color', color: projectData.canvas.backgroundColor };
                            }
                        }
                        
                        // Restaurar capas
                        layers = [];
                        currentLayer = projectData.currentLayer || 0;
                        nextLayerId = projectData.nextLayerId || 1;
                        
                        // Procesar cada capa
                        projectData.layers.forEach((layerData, index) => {
                            const layer = {
                                id: layerData.id,
                                name: layerData.name,
                                visible: layerData.visible,
                                opacity: layerData.opacity,
                                shapes: []
                            };
                            
                            // Procesar formas de la capa
                            if (layerData.shapes) {
                                layerData.shapes.forEach(shapeData => {
                                    const shape = { ...shapeData };
                                    
                                    // Si es una imagen, reconstruir el objeto Image
                                    if (shape.type === 'image' && shape.imageData) {
                                        const img = new Image();
                                        img.onload = function() {
                                            shape.image = img;
                                            // Redibujar cuando se cargue la imagen
                                            redrawCanvasWithShapes();
                                        };
                                        img.src = shape.imageData;
                                        delete shape.imageData;
                                    }
                                    
                                    layer.shapes.push(shape);
                                });
                            }
                            
                            layers.push(layer);
                        });
                        
                        // Restaurar configuraciones
                        if (projectData.settings) {
                            showGrid = projectData.settings.gridEnabled || false;
                            gridSize = projectData.settings.gridSize || 20;
                            brushSize = projectData.settings.brushSize || 5;
                            currentColor = projectData.settings.currentColor || '#000000';
                            currentColor2 = projectData.settings.currentColor2 || '#ffffff';
                            fillStyle = projectData.settings.fillStyle || 'none';
                            opacity = projectData.settings.opacity || 1.0;
                            
                            // Actualizar UI
                            document.getElementById('colorPicker').value = currentColor;
                            document.getElementById('colorPicker2').value = currentColor2;
                            document.getElementById('brushSize').value = brushSize;
                            updateBrushPreview();
                        }
                        
                        // Restaurar nombre del proyecto
                        projectName = projectData.name || file.name.replace('.paintpro', '').replace('.json', '');
                        
                        // Cargar figuras de la capa actual
                        if (layers[currentLayer]) {
                            shapes = [...layers[currentLayer].shapes];
                        } else {
                            shapes = [];
                        }
                        
                        // Redibujar todo
                        redrawCanvasWithShapes();
                        updateLayersList();
                        saveShapesState();
                        updateWindowTitle();
                        
                        showNotification(`Proyecto "${projectName}" cargado exitosamente`, 'success');
                        
                    } catch (err) {
                        console.error('Error cargando proyecto:', err);
                        showNotification('Error al cargar el proyecto. Archivo corrupto o formato no v√°lido.', 'error');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        function saveAsProject() {
            const newName = prompt('Nombre del proyecto:', projectName);
            if (newName !== null && newName.trim() !== '') {
                projectName = newName.trim();
                saveProject();
            }
        }

        function updateWindowTitle() {
            document.title = `Paint Pro - ${projectName}`;
        }

        function enableAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
            
            if (autoSaveEnabled) {
                autoSaveInterval = setInterval(() => {
                    try {
                        const projectData = {
                            version: '2.0',
                            name: projectName,
                            timestamp: new Date().toISOString(),
                            canvas: {
                                width: canvas.width,
                                height: canvas.height
                            },
                            layers: layers,
                            currentLayer: currentLayer,
                            nextLayerId: nextLayerId,
                            settings: {
                                gridEnabled: showGrid,
                                gridSize: gridSize,
                                brushSize: brushSize,
                                currentColor: currentColor,
                                currentColor2: currentColor2
                            }
                        };
                        // Persistir fondo tambi√©n en autoguardado
                        try { projectData.canvas.background = JSON.parse(JSON.stringify(backgroundState)); } catch(e) { /* ignore */ }
                        
                        localStorage.setItem('paintpro_autosave', JSON.stringify(projectData));
                        console.log('Autoguardado realizado');
                        
                    } catch (err) {
                        console.error('Error en autoguardado:', err);
                    }
                }, 30000); // Autoguardar cada 30 segundos
            }
        }

        function loadAutoSave() {
            try {
                const autoSaveData = localStorage.getItem('paintpro_autosave');
                // Solo mostrar el di√°logo si la √∫ltima salida NO fue limpia (p.ej. cierre inesperado)
                const lastExitClean = localStorage.getItem('paintpro_last_exit_clean') === 'true';

                if (autoSaveData && !lastExitClean) {
                    const confirmed = confirm('Se detect√≥ un autoguardado de una sesi√≥n previa que no se cerr√≥ correctamente. ¬øDeseas recuperar tu trabajo anterior?');
                    if (confirmed) {
                        const projectData = JSON.parse(autoSaveData);
                        
                        // Restaurar configuraci√≥n del canvas
                        if (projectData.canvas) {
                            canvas.width = projectData.canvas.width || 800;
                            canvas.height = projectData.canvas.height || 600;
                            if (projectData.canvas.background) {
                                backgroundState = projectData.canvas.background;
                            } else if (projectData.canvas.backgroundColor) {
                                backgroundState = { type: 'color', color: projectData.canvas.backgroundColor };
                            }
                        }
                        
                        // Restaurar capas
                        layers = projectData.layers || [];
                        currentLayer = projectData.currentLayer || 0;
                        nextLayerId = projectData.nextLayerId || 1;
                        
                        // Restaurar configuraciones
                        if (projectData.settings) {
                            showGrid = projectData.settings.gridEnabled || false;
                            gridSize = projectData.settings.gridSize || 20;
                            brushSize = projectData.settings.brushSize || 5;
                            currentColor = projectData.settings.currentColor || '#000000';
                            currentColor2 = projectData.settings.currentColor2 || '#ffffff';
                        }
                        
                        // Restaurar nombre del proyecto
                        projectName = projectData.name || 'Recuperado';
                        
                        // Cargar figuras de la capa actual
                        if (layers[currentLayer]) {
                            shapes = [...layers[currentLayer].shapes];
                        } else {
                            shapes = [];
                        }
                        
                        // Redibujar todo
                        redrawCanvasWithShapes();
                        updateLayersList();
                        saveShapesState();
                        updateWindowTitle();
                        
                        // Limpiar el autoguardado antiguo; se volver√° a crear autom√°ticamente
                        // en esta sesi√≥n si el autoguardado est√° activo.
                        try { localStorage.removeItem('paintpro_autosave'); } catch(e) { /* ignore */ }

                        showNotification('Trabajo anterior recuperado del autoguardado', 'success');
                    } else {
                        // Si no quiere recuperar, limpiar el autoguardado
                        localStorage.removeItem('paintpro_autosave');
                    }
                }
            } catch (err) {
                console.error('Error recuperando autoguardado:', err);
                localStorage.removeItem('paintpro_autosave'); // Limpiar datos corruptos
            }
        }

        function toggleAutoSave() {
            autoSaveEnabled = !autoSaveEnabled;
            if (autoSaveEnabled) {
                enableAutoSave();
                showNotification('Autoguardado activado', 'success');
            } else {
                if (autoSaveInterval) {
                    clearInterval(autoSaveInterval);
                    autoSaveInterval = null;
                }
                showNotification('Autoguardado desactivado', 'warning');
            }
        }

        // ==========================================
        // FUNCIONES DE COPIAR Y PEGAR
        // ==========================================

        function copyCanvasToClipboard() {
            try {
                // Si hay una selecci√≥n activa, copiar solo esa √°rea
                if (activeSelection && selectionImageData) {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = activeSelection.width;
                    tempCanvas.height = activeSelection.height;
                    
                    // Aplicar selecci√≥n transparente si est√° activada
                    if (transparentSelection) {
                        // Copiar imageData pero hacer transparente el blanco
                        const imgData = ctx.getImageData(
                            activeSelection.x,
                            activeSelection.y,
                            activeSelection.width,
                            activeSelection.height
                        );
                        
                        // Hacer transparente el color blanco
                        for (let i = 0; i < imgData.data.length; i += 4) {
                            const r = imgData.data[i];
                            const g = imgData.data[i + 1];
                            const b = imgData.data[i + 2];
                            
                            // Si es blanco (o muy cercano), hacerlo transparente
                            if (r > 250 && g > 250 && b > 250) {
                                imgData.data[i + 3] = 0; // Alpha = 0
                            }
                        }
                        
                        tempCtx.putImageData(imgData, 0, 0);
                    } else {
                        // Copiar normalmente
                        tempCtx.putImageData(selectionImageData, 0, 0);
                    }
                    
                    // Convertir a blob y copiar al portapapeles
                    tempCanvas.toBlob(async (blob) => {
                        try {
                            await navigator.clipboard.write([
                                new ClipboardItem({ 'image/png': blob })
                            ]);
                            showNotification('Selecci√≥n copiada al portapapeles', 'success');
                        } catch (err) {
                            console.error('Error copiando al portapapeles:', err);
                            showNotification('Error al copiar al portapapeles', 'error');
                        }
                    });
                } else {
                    // Si no hay selecci√≥n, copiar todo el canvas
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    
                    // Copiar el contenido del canvas principal
                    tempCtx.drawImage(canvas, 0, 0);
                    
                    // Convertir a blob y copiar al portapapeles
                    tempCanvas.toBlob(async (blob) => {
                        try {
                            await navigator.clipboard.write([
                                new ClipboardItem({ 'image/png': blob })
                            ]);
                            showNotification('Canvas copiado al portapapeles', 'success');
                        } catch (err) {
                            console.error('Error copiando al portapapeles:', err);
                            showNotification('Error al copiar al portapapeles', 'error');
                        }
                    });
                }
            } catch (err) {
                console.error('Error en copyCanvasToClipboard:', err);
                showNotification('Error al copiar', 'error');
            }
        }

        function pasteFromClipboard() {
            try {
                navigator.clipboard.read().then(clipboardItems => {
                    for (const clipboardItem of clipboardItems) {
                        for (const type of clipboardItem.types) {
                            if (type.startsWith('image/')) {
                                clipboardItem.getType(type).then(blob => {
                                    const img = new Image();
                                    img.onload = function() {
                                        // Convertir la imagen a base64 inmediatamente
                                        const tempCanvas = document.createElement('canvas');
                                        const tempCtx = tempCanvas.getContext('2d');
                                        tempCanvas.width = img.width;
                                        tempCanvas.height = img.height;
                                        tempCtx.drawImage(img, 0, 0);
                                        const imageData = tempCanvas.toDataURL('image/png');
                                        
                                        // Crear una nueva figura de imagen con imageData guardado
                                        const imageShape = {
                                            type: 'image',
                                            x: 50,
                                            y: 50,
                                            width: img.width,
                                            height: img.height,
                                            image: img,
                                            imageData: imageData, // Guardar base64 para persistencia
                                            selected: false
                                        };
                                        
                                        // Agregar a la capa actual
                                        shapes.push(imageShape);
                                        saveShapesState();
                                        redrawCanvasWithShapes();
                                        showNotification('Imagen pegada desde el portapapeles', 'success');
                                    };
                                    img.src = URL.createObjectURL(blob);
                                });
                                return;
                            }
                        }
                    }
                    showNotification('No se encontr√≥ imagen en el portapapeles', 'warning');
                }).catch(err => {
                    console.error('Error leyendo portapapeles:', err);
                    showNotification('Error al acceder al portapapeles', 'error');
                });
            } catch (err) {
                console.error('Error en pasteFromClipboard:', err);
                showNotification('Funci√≥n de pegar no soportada en este navegador', 'error');
            }
        }

        // Funci√≥n para mostrar notificaciones
        function showNotification(message, type = 'info') {
            // Crear elemento de notificaci√≥n
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : type === 'warning' ? '#ff9800' : '#2196F3'};
                color: white;
                border-radius: 4px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                z-index: 10000;
                font-family: Arial, sans-serif;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            
            document.body.appendChild(notification);
            
            // Animar entrada
            setTimeout(() => {
                notification.style.opacity = '1';
            }, 10);
            
            // Remover despu√©s de 3 segundos
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // Funci√≥n para manejar archivos arrastrados
        function handleFileDrop(e) {
            e.preventDefault();
            const files = e.dataTransfer.files;
            
            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = new Image();
                        img.onload = function() {
                            // Convertir la imagen a base64 inmediatamente
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = img.width;
                            tempCanvas.height = img.height;
                            tempCtx.drawImage(img, 0, 0);
                            const imageData = tempCanvas.toDataURL('image/png');
                            
                            // Crear una nueva figura de imagen
                            const imageShape = {
                                type: 'image',
                                x: 50,
                                y: 50,
                                width: img.width,
                                height: img.height,
                                image: img,
                                imageData: imageData, // Guardar base64 para persistencia
                                selected: false
                            };
                            
                            // Agregar a la capa actual
                            shapes.push(imageShape);
                            saveShapesState();
                            redrawCanvasWithShapes();
                            showNotification(`Imagen "${file.name}" agregada al canvas`, 'success');
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            canvas.style.opacity = '0.8';
        }

        function handleDragLeave(e) {
            e.preventDefault();
            canvas.style.opacity = '1';
        }

        // Initialize
        init();
    </script>
</body>
</html>